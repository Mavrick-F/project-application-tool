<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Memphis MPO - Project Application Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS for map rendering -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

  <!-- Leaflet Draw CSS for drawing tools -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

  <style>
    /* ============================================
       RESET & BASE STYLES
       ============================================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      color: #333333;
      background-color: #ffffff;
      overflow: hidden;
    }

    /* ============================================
       LAYOUT
       ============================================ */
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    /* Top header bar */
    header {
      display: flex;
      align-items: center;
      padding: 15px 20px;
      background-color: #1565C0;
      color: white;
      min-height: 80px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    header img {
      height: 60px;
      max-width: 200px;
      margin-right: 20px;
      object-fit: contain;
    }

    header h1 {
      font-size: 20px;
      font-weight: bold;
    }

    /* Main container with sidebar and map */
    #container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Left sidebar for results */
    #sidebar {
      width: 350px;
      background-color: #F5F5F5;
      overflow-y: auto;
      padding: 20px;
      border-right: 1px solid #CCCCCC;
    }

    /* Map container */
    #map {
      flex: 1;
      position: relative;
    }

    /* ============================================
       SIDEBAR COMPONENTS
       ============================================ */
    .sidebar-section {
      margin-bottom: 25px;
    }

    .section-heading {
      font-size: 16px;
      font-weight: bold;
      color: #1565C0;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .divider {
      height: 1px;
      background-color: #CCCCCC;
      margin: 20px 0;
    }

    /* Project name input */
    #projectName {
      width: 100%;
      padding: 10px;
      border: 1px solid #CCCCCC;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
    }

    #projectName:focus {
      outline: none;
      border-color: #1565C0;
      box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.1);
    }

    /* Project name section - hidden until drawing complete */
    #projectNameSection {
      display: none;
    }

    #projectNameSection.visible {
      display: block;
    }

    /* Results lists */
    .results-list {
      list-style: none;
      padding-left: 0;
    }

    .results-list li {
      padding: 5px 0;
      padding-left: 15px;
      position: relative;
    }

    .results-list li:before {
      content: "•";
      position: absolute;
      left: 0;
      color: #1565C0;
      font-weight: bold;
    }

    .empty-state {
      color: #666666;
      font-style: italic;
      padding: 5px 0;
    }

    /* Results card styling */
    .results-card {
      background-color: white;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 15px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      border-left: 3px solid #1565C0;
    }

    .results-card.routes { border-left-color: #0066CC; }
    .results-card.zones { border-left-color: #FF8C00; }
    .results-card.bridges { border-left-color: #DC143C; }

    .results-card .section-heading {
      margin-bottom: 8px;
      font-size: 14px;
    }

    .result-count {
      display: inline-block;
      background-color: #E3F2FD;
      color: #1565C0;
      font-size: 11px;
      font-weight: bold;
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: 8px;
    }

    .results-card.routes .result-count { background-color: #E3F2FD; color: #0066CC; }
    .results-card.zones .result-count { background-color: #FFF3E0; color: #E65100; }
    .results-card.bridges .result-count { background-color: #FFEBEE; color: #C62828; }

    /* Bridges table */
    #bridgesTable {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      background-color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    #bridgesTable th {
      background-color: #E6F2FF;
      padding: 10px;
      text-align: left;
      font-weight: bold;
      border: 1px solid #CCCCCC;
      font-size: 12px;
    }

    #bridgesTable td {
      padding: 8px 10px;
      border: 1px solid #CCCCCC;
      font-size: 12px;
    }

    #bridgesTable tr:nth-child(even) {
      background-color: #F9F9F9;
    }

    /* Buttons */
    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s;
      font-family: inherit;
    }

    .btn-primary {
      background-color: #1565C0;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background-color: #0D47A1;
    }

    .btn-primary:disabled {
      background-color: #CCCCCC;
      cursor: not-allowed;
    }

    .btn-secondary {
      background-color: #666666;
      color: white;
      margin-top: 10px;
    }

    .btn-secondary:hover {
      background-color: #444444;
    }

    .btn-draw {
      background-color: #1565C0;
      color: white;
      margin-bottom: 10px;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: left;
    }

    .btn-draw:hover {
      background-color: #0D47A1;
    }

    .btn-draw.active {
      background-color: #43A047;
      box-shadow: 0 0 0 3px rgba(67, 160, 71, 0.3);
    }

    .btn-draw.active:hover {
      background-color: #2E7D32;
    }

    /* Helper text */
    .helper-text {
      font-size: 12px;
      color: #666666;
      margin-top: 5px;
    }

    /* ============================================
       LOADING OVERLAY
       ============================================ */
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #004C97;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #loadingText {
      margin-top: 20px;
      font-size: 16px;
      color: #333333;
    }

    /* ============================================
       RESPONSIVE WARNING
       ============================================ */
    #mobileWarning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      z-index: 10000;
    }

    @media (max-width: 1024px) {
      #mobileWarning {
        display: flex;
      }

      #app {
        display: none;
      }
    }

    /* ============================================
       LEAFLET CUSTOMIZATIONS
       ============================================ */
    .leaflet-draw-toolbar a {
      background-color: #1565C0;
    }

    .leaflet-draw-draw-polyline {
      background-color: #1565C0;
    }

    /* Custom tooltip styling */
    .leaflet-tooltip {
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      font-size: 12px;
    }

    /* Layer control styling */
    .leaflet-control-layers {
      background-color: white;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      padding: 8px 12px;
    }

    .leaflet-control-layers-list {
      font-size: 13px;
    }

    .leaflet-control-layers label {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 4px 0;
      cursor: pointer;
    }

    .leaflet-control-layers-overlays {
      padding-top: 5px;
    }

    /* Scale control styling */
    .leaflet-control-scale-line {
      background-color: rgba(255,255,255,0.8);
      border: 1px solid #666;
      border-top: none;
      font-size: 11px;
      padding: 2px 5px;
    }

    /* ============================================
       TUTORIAL POPUP
       ============================================ */
    #tutorialPopup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      padding: 30px;
      max-width: 500px;
      z-index: 10001;
      display: none;
    }

    #tutorialPopup.visible {
      display: block;
    }

    #tutorialOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      display: none;
    }

    #tutorialOverlay.visible {
      display: block;
    }

    #tutorialPopup h2 {
      margin: 0 0 20px 0;
      color: #1565C0;
      font-size: 22px;
      font-weight: bold;
    }

    #tutorialPopup ul {
      list-style: none;
      padding: 0;
      margin: 0 0 25px 0;
    }

    #tutorialPopup li {
      padding: 12px 0 12px 30px;
      position: relative;
      line-height: 1.6;
      color: #333;
      font-size: 15px;
    }

    #tutorialPopup li:before {
      content: "✓";
      position: absolute;
      left: 0;
      color: #1565C0;
      font-weight: bold;
      font-size: 18px;
    }

    #tutorialPopup .tutorial-close {
      width: 100%;
      padding: 12px;
      background-color: #1565C0;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    #tutorialPopup .tutorial-close:hover {
      background-color: #0D47A1;
    }
  </style>
</head>
<body>
  <!-- Mobile/small screen warning -->
  <div id="mobileWarning">
    <div>
      <h2>Desktop Browser Required</h2>
      <p>This tool requires a desktop browser with a minimum width of 1024px.</p>
    </div>
  </div>

  <!-- Main application -->
  <div id="app">
    <!-- Header -->
    <header>
      <img src="./assets/rtp-2055-logo.jpg" alt="RTP 2055 Logo">
      <h1>Project Application Tool</h1>
    </header>

    <!-- Main container -->
    <div id="container">
      <!-- Sidebar -->
      <aside id="sidebar">
        <div class="sidebar-section">
          <div class="section-heading">Draw Your Project</div>
          <button class="btn btn-draw" id="drawLineButton">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
              <line x1="5" y1="19" x2="19" y2="5"></line>
              <circle cx="5" cy="19" r="2"></circle>
              <circle cx="19" cy="5" r="2"></circle>
            </svg>
            Draw Alignment (Line)
          </button>
          <button class="btn btn-draw" id="drawPointButton">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
              <circle cx="12" cy="10" r="3"></circle>
            </svg>
            Mark Location (Point)
          </button>
          <div class="helper-text">Choose line for corridor projects or point for specific locations</div>
          <button class="btn btn-secondary" id="zoomExtentButton" style="margin-top: 10px; display: flex; align-items: center; justify-content: center;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px;">
              <rect x="3" y="3" width="18" height="18" rx="2"></rect>
              <path d="M9 3v18M15 3v18M3 9h18M3 15h18"></path>
            </svg>
            Zoom to Full Extent
          </button>
        </div>

        <div class="divider"></div>

        <!-- Project name and PDF section - hidden until drawing complete -->
        <div id="projectNameSection">
          <div class="sidebar-section">
            <div class="section-heading">Generate Report</div>
            <label for="projectName" style="font-size: 13px; color: #666; margin-bottom: 5px; display: block;">Project Name</label>
            <input
              type="text"
              id="projectName"
              placeholder="Enter project name..."
              aria-label="Project Name"
            >
            <div class="helper-text" style="margin-bottom: 15px;">Required for PDF report</div>

            <button class="btn btn-primary" id="pdfButton" disabled>
              Download PDF Report
            </button>

            <button class="btn btn-secondary" id="clearButton">
              Clear & Start Over
            </button>
          </div>

          <div class="divider"></div>
        </div>

        <div class="sidebar-section">
          <div class="section-heading">Analysis Results</div>

          <div class="results-card routes">
            <div class="section-heading">MATA Routes <span class="result-count" id="routesCount">0</span></div>
            <ul class="results-list" id="routesList">
              <li class="empty-state">Draw a project to see results</li>
            </ul>
          </div>

          <div class="results-card zones">
            <div class="section-heading">Opportunity Zones <span class="result-count" id="zonesCount">0</span></div>
            <ul class="results-list" id="zonesList">
              <li class="empty-state">Draw a project to see results</li>
            </ul>
          </div>

          <div class="results-card bridges">
            <div class="section-heading">Bridges (within 300 ft) <span class="result-count" id="bridgesCount">0</span></div>
            <div id="bridgesContainer">
              <p class="empty-state">Draw a project to see results</p>
            </div>
          </div>
        </div>
      </aside>

      <!-- Map -->
      <div id="map"></div>
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingText">Loading map data...</div>
  </div>

  <!-- Tutorial popup -->
  <div id="tutorialOverlay"></div>
  <div id="tutorialPopup">
    <h2>Welcome to the Project Application Tool</h2>
    <ul>
      <li>Draw a line for corridor projects OR a point for intersection/spot improvements</li>
      <li>Your line will find routes running parallel for at least 300ft</li>
      <li>Results auto-update when you finish drawing</li>
    </ul>
    <button class="tutorial-close" id="tutorialCloseButton">Got it!</button>
  </div>

  <!-- CDN Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      // Spatial analysis parameters
      bridgeBufferDistance: 300,      // Buffer distance in feet for bridge proximity
      bridgeBufferUnits: 'feet',      // Units for buffer calculation
      minLineLength: 100,             // Minimum project length in feet

      // Map configuration
      mapCenter: null,                // Auto-calculated from data bounds
      mapZoom: 11,                    // Default zoom level
      basemapUrl: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
      basemapAttribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',

      // Data file paths
      dataUrls: {
        routes: './data/mata-routes.json',
        zones: './data/opportunity-zones.json',
        bridges: './data/bridges.json',
        // Feature Service configuration for functional classification
        // NOTE: Current URL returns 403 - requires authentication or is not publicly accessible
        functionalClass: {
          type: 'featureService',
          url: 'https://services2.arcgis.com/saWmpKJIUAjyyNVc/arcgis/rest/services/ETRIMS_Roads_All/FeatureServer/0',
          // Backup: This URL may need to be updated once IT publishes the public service
          enabled: false  // Set to true once endpoint is accessible
        }
      },

      // Map layer styles
      styles: {
        routes: {
          color: '#0066CC',
          weight: 2,
          opacity: 0.7
        },
        routesHover: {
          weight: 2.5,
          opacity: 0.85
        },
        zones: {
          color: '#FF8C00',
          weight: 2,
          fillColor: '#FFD700',
          fillOpacity: 0.3
        },
        zonesHover: {
          fillOpacity: 0.5
        },
        bridges: {
          color: '#DC143C',
          fillColor: '#DC143C',
          radius: 3,
          fillOpacity: 0.8,
          weight: 1
        },
        bridgesHover: {
          radius: 5
        },
        drawnLine: {
          color: '#FF0000',
          weight: 8,
          opacity: 0.8
        }
      },

      // Logo path
      logoPath: './assets/rtp-2055-logo.jpg'
    };

    // ============================================
    // GLOBAL STATE
    // ============================================
    let map;                          // Leaflet map instance
    let drawControl;                  // Leaflet.draw control
    let drawnLayer = null;            // Currently drawn polyline layer
    let drawnGeometry = null;         // GeoJSON of drawn line
    let drawnItems;                   // Feature group for drawn items
    let polylineDrawer;               // Polyline draw handler
    let markerDrawer;                 // Marker draw handler

    // Layer groups for reference data
    let featureLayers = {
      routes: null,
      zones: null,
      bridges: null
    };

    // Raw GeoJSON data (cached after loading)
    let geoJsonData = {
      routes: null,
      zones: null,
      bridges: null
    };

    // Analysis results
    let currentResults = {
      routes: [],
      zones: [],
      bridges: []
    };

    // ============================================
    // INITIALIZATION
    // ============================================

    /**
     * Initialize the application
     * - Loads all GeoJSON data
     * - Initializes the map
     * - Sets up drawing controls
     * - Configures event listeners
     */
    async function init() {
      try {
        showLoading(true, 'Loading map data...');

        // Load all GeoJSON files
        await loadGeoJsonData();

        // Initialize the Leaflet map
        initializeMap();

        // Add reference layers to map
        addReferenceLayers();

        // Calculate and fit map to data bounds
        fitMapToBounds();

        // Set up drawing controls
        setupDrawingControls();

        // Set up event listeners
        setupEventListeners();

        // Hide loading overlay
        showLoading(false);

        // Show tutorial popup if first visit
        showTutorialIfFirstVisit();

      } catch (error) {
        console.error('Initialization error:', error);
        showError('Failed to initialize the application. Please refresh the page.');
      }
    }

    /**
     * Show tutorial popup on first visit
     * Uses localStorage to track if user has seen the tutorial
     */
    function showTutorialIfFirstVisit() {
      const hasSeenTutorial = localStorage.getItem('hasSeenTutorial');

      if (!hasSeenTutorial) {
        // Show tutorial popup
        document.getElementById('tutorialOverlay').classList.add('visible');
        document.getElementById('tutorialPopup').classList.add('visible');
      }
    }

    /**
     * Close tutorial popup and mark as seen
     */
    function closeTutorial() {
      document.getElementById('tutorialOverlay').classList.remove('visible');
      document.getElementById('tutorialPopup').classList.remove('visible');
      localStorage.setItem('hasSeenTutorial', 'true');
    }

    // ============================================
    // FEATURE SERVICE QUERY MODULE
    // ============================================

    /**
     * Query an ArcGIS Feature Service and return results as GeoJSON
     * @param {string} serviceUrl - The Feature Service layer URL (ending in /FeatureServer/N)
     * @param {Object} options - Query options
     * @param {Array} options.bbox - Bounding box [minX, minY, maxX, maxY] in WGS84
     * @param {string} options.where - SQL where clause (default: "1=1")
     * @param {Array} options.outFields - Fields to return (default: ["*"])
     * @param {number} options.maxRecords - Max features to return (default: 1000)
     * @param {boolean} options.returnGeometry - Whether to return geometry (default: true)
     * @returns {Promise<Object>} - Object with {success, data, error}
     */
    async function queryFeatureService(serviceUrl, options = {}) {
      const {
        bbox = null,
        where = '1=1',
        outFields = ['*'],
        maxRecords = 1000,
        returnGeometry = true
      } = options;

      try {
        // Build query parameters
        const params = new URLSearchParams({
          where: where,
          outFields: outFields.join(','),
          returnGeometry: returnGeometry.toString(),
          f: 'json',
          outSR: '4326'  // Request WGS84 coordinates
        });

        // Add bbox if provided
        if (bbox && Array.isArray(bbox) && bbox.length === 4) {
          const geometryObj = {
            xmin: bbox[0],
            ymin: bbox[1],
            xmax: bbox[2],
            ymax: bbox[3],
            spatialReference: { wkid: 4326 }
          };
          params.append('geometry', JSON.stringify(geometryObj));
          params.append('geometryType', 'esriGeometryEnvelope');
          params.append('spatialRel', 'esriSpatialRelIntersects');
          params.append('inSR', '4326');
        }

        // First, get count to determine if pagination is needed
        const countUrl = `${serviceUrl}/query?${new URLSearchParams({
          where: where,
          returnCountOnly: 'true',
          f: 'json'
        })}`;

        console.log('Querying feature count:', countUrl);
        const countResponse = await fetch(countUrl);

        if (!countResponse.ok) {
          throw new Error(`HTTP ${countResponse.status}: ${countResponse.statusText}`);
        }

        const countData = await countResponse.json();

        // Check for ArcGIS error response
        if (countData.error) {
          throw new Error(`ArcGIS Error ${countData.error.code}: ${countData.error.message}`);
        }

        const totalCount = countData.count || 0;
        console.log(`Total features matching query: ${totalCount}`);

        // Collect all features (handle pagination if needed)
        const allFeatures = [];
        let resultOffset = 0;
        const recordsPerRequest = Math.min(maxRecords, 1000); // ArcGIS default max is often 1000

        do {
          // Add pagination parameters
          params.set('resultRecordCount', recordsPerRequest.toString());
          params.set('resultOffset', resultOffset.toString());

          const queryUrl = `${serviceUrl}/query?${params}`;
          console.log(`Fetching features (offset: ${resultOffset})...`);

          const response = await fetch(queryUrl);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();

          // Check for ArcGIS error response
          if (data.error) {
            throw new Error(`ArcGIS Error ${data.error.code}: ${data.error.message}`);
          }

          // Check if we got features
          if (!data.features || !Array.isArray(data.features)) {
            console.warn('No features array in response');
            break;
          }

          console.log(`Received ${data.features.length} features`);
          allFeatures.push(...data.features);

          // Check if there are more results
          if (!data.exceededTransferLimit && data.features.length < recordsPerRequest) {
            // No more results
            break;
          }

          resultOffset += data.features.length;

          // Safety check: don't exceed maxRecords
          if (allFeatures.length >= maxRecords) {
            console.log(`Reached maxRecords limit (${maxRecords})`);
            break;
          }

        } while (resultOffset < totalCount);

        console.log(`Total features retrieved: ${allFeatures.length}`);

        // Convert ArcGIS JSON to GeoJSON
        // We need the geometry type and spatial reference from the response
        // Make one more request to get service metadata if we don't have features
        let geometryType = null;
        let spatialReference = null;

        if (allFeatures.length > 0) {
          // Try to infer from first feature
          const firstFeature = allFeatures[0];
          if (firstFeature.geometry) {
            // Determine geometry type from structure
            if (firstFeature.geometry.x !== undefined) {
              geometryType = 'esriGeometryPoint';
            } else if (firstFeature.geometry.paths) {
              geometryType = 'esriGeometryPolyline';
            } else if (firstFeature.geometry.rings) {
              geometryType = 'esriGeometryPolygon';
            }
          }
        }

        // Convert to GeoJSON
        const geojson = convertArcGISToGeoJSON(allFeatures, geometryType, spatialReference);

        return {
          success: true,
          data: geojson,
          error: null,
          metadata: {
            totalCount: totalCount,
            retrievedCount: allFeatures.length,
            geometryType: geometryType
          }
        };

      } catch (error) {
        console.error('Feature Service query error:', error);
        return {
          success: false,
          data: null,
          error: error.message || 'Unknown error occurred'
        };
      }
    }

    /**
     * Convert ArcGIS JSON format to GeoJSON format
     * @param {Array} features - Array of ArcGIS features
     * @param {string} geometryType - ArcGIS geometry type (esriGeometryPoint, esriGeometryPolyline, esriGeometryPolygon)
     * @param {Object} spatialReference - Spatial reference object
     * @returns {Object} - GeoJSON FeatureCollection
     */
    function convertArcGISToGeoJSON(features, geometryType, spatialReference) {
      const geojsonFeatures = features.map(feature => {
        // Convert geometry
        const geojsonGeometry = convertArcGISGeometry(feature.geometry, geometryType);

        // Extract properties (attributes)
        const properties = feature.attributes || {};

        return {
          type: 'Feature',
          properties: properties,
          geometry: geojsonGeometry
        };
      });

      return {
        type: 'FeatureCollection',
        features: geojsonFeatures
      };
    }

    /**
     * Convert ArcGIS geometry to GeoJSON geometry
     * @param {Object} arcgisGeom - ArcGIS geometry object
     * @param {string} geometryType - ArcGIS geometry type
     * @returns {Object} - GeoJSON geometry object
     */
    function convertArcGISGeometry(arcgisGeom, geometryType) {
      if (!arcgisGeom) {
        return null;
      }

      // Point geometry
      if (arcgisGeom.x !== undefined && arcgisGeom.y !== undefined) {
        return {
          type: 'Point',
          coordinates: [arcgisGeom.x, arcgisGeom.y]
        };
      }

      // Polyline geometry
      if (arcgisGeom.paths) {
        if (arcgisGeom.paths.length === 1) {
          // Single LineString
          return {
            type: 'LineString',
            coordinates: arcgisGeom.paths[0]
          };
        } else {
          // MultiLineString
          return {
            type: 'MultiLineString',
            coordinates: arcgisGeom.paths
          };
        }
      }

      // Polygon geometry
      if (arcgisGeom.rings) {
        // ArcGIS rings can represent multiple polygons or polygons with holes
        // For simplicity, we'll treat single ring as Polygon, multiple as MultiPolygon
        if (arcgisGeom.rings.length === 1) {
          return {
            type: 'Polygon',
            coordinates: arcgisGeom.rings
          };
        } else {
          // For proper MultiPolygon, we'd need to determine which rings are holes
          // This is a simplified version
          return {
            type: 'MultiPolygon',
            coordinates: arcgisGeom.rings.map(ring => [ring])
          };
        }
      }

      console.warn('Unknown geometry type:', arcgisGeom);
      return null;
    }

    /**
     * Test Feature Service integration with functional classification
     * This function is called when drawing is complete to test the integration
     * @param {Object} drawnGeometry - GeoJSON geometry of drawn line or point
     */
    async function testFeatureServiceIntegration(drawnGeometry) {
      // Only run if Feature Service is enabled
      if (!CONFIG.dataUrls.functionalClass.enabled) {
        console.log('Feature Service integration disabled. Set CONFIG.dataUrls.functionalClass.enabled = true to test.');
        return;
      }

      console.log('=== Testing Feature Service Integration ===');

      try {
        // Get bounding box of drawn geometry with buffer
        const buffered = turf.buffer(drawnGeometry, 500, { units: 'feet' });
        const bbox = turf.bbox(buffered);

        console.log('Querying functional classification within bbox:', bbox);

        // Query Feature Service
        const result = await queryFeatureService(CONFIG.dataUrls.functionalClass.url, {
          bbox: bbox,
          where: '1=1',
          outFields: ['*'],
          maxRecords: 100
        });

        if (result.success) {
          console.log('✓ Feature Service query successful!');
          console.log(`  Retrieved ${result.data.features.length} features`);
          console.log(`  Total count: ${result.metadata.totalCount}`);
          console.log(`  Geometry type: ${result.metadata.geometryType}`);

          // Log first feature for inspection
          if (result.data.features.length > 0) {
            console.log('  First feature sample:', result.data.features[0]);
          }

          // Test spatial analysis with Turf.js
          console.log('Testing spatial analysis with Turf.js...');
          const intersecting = result.data.features.filter(roadFeature => {
            try {
              return turf.booleanIntersects(buffered, roadFeature);
            } catch (e) {
              return false;
            }
          });
          console.log(`  ${intersecting.length} roads intersect the buffered area`);

        } else {
          console.error('✗ Feature Service query failed:', result.error);
        }

      } catch (error) {
        console.error('✗ Feature Service integration test error:', error);
      }

      console.log('=== End Feature Service Integration Test ===');
    }

    // ============================================
    // DATA LOADING
    // ============================================

    /**
     * Load all GeoJSON data files from the data directory
     * Fetches MATA routes, opportunity zones, and bridges data
     * @returns {Promise} Resolves when all data is loaded
     */
    async function loadGeoJsonData() {
      try {
        // Fetch all three datasets in parallel for better performance
        const [routesResponse, zonesResponse, bridgesResponse] = await Promise.all([
          fetch(CONFIG.dataUrls.routes),
          fetch(CONFIG.dataUrls.zones),
          fetch(CONFIG.dataUrls.bridges)
        ]);

        // Check for fetch errors
        if (!routesResponse.ok) throw new Error('Failed to load MATA routes data');
        if (!zonesResponse.ok) throw new Error('Failed to load opportunity zones data');
        if (!bridgesResponse.ok) throw new Error('Failed to load bridges data');

        // Parse JSON data
        geoJsonData.routes = await routesResponse.json();
        geoJsonData.zones = await zonesResponse.json();
        geoJsonData.bridges = await bridgesResponse.json();

        console.log('Data loaded successfully:', {
          routes: geoJsonData.routes.features.length,
          zones: geoJsonData.zones.features.length,
          bridges: geoJsonData.bridges.features.length
        });

      } catch (error) {
        console.error('Error loading GeoJSON data:', error);
        throw error;
      }
    }

    /**
     * Initialize the Leaflet map with basemap
     */
    function initializeMap() {
      // Create map instance
      map = L.map('map', {
        zoomControl: true,
        attributionControl: true
      });

      // Add CartoDB Voyager basemap (streets style, similar to Google Maps)
      const basemap = L.tileLayer(CONFIG.basemapUrl, {
        attribution: CONFIG.basemapAttribution,
        maxZoom: 19
      }).addTo(map);

      // Add scale control (bottom left)
      L.control.scale({
        imperial: true,
        metric: false,
        position: 'bottomleft'
      }).addTo(map);
    }

    /**
     * Add all reference layers (routes, zones, bridges) to the map
     * Configures styling, popups, and hover interactions
     */
    function addReferenceLayers() {
      // ========== MATA ROUTES LAYER ==========
      featureLayers.routes = L.geoJSON(geoJsonData.routes, {
        style: CONFIG.styles.routes,
        onEachFeature: (feature, layer) => {
          const routeName = feature.properties.Name || 'Unknown Route';

          // Bind tooltip for hover info only (no click popup)
          layer.bindTooltip(routeName, {
            sticky: true,
            className: 'leaflet-tooltip'
          });

          // Hover effects
          layer.on('mouseover', function() {
            this.setStyle(CONFIG.styles.routesHover);
          });

          layer.on('mouseout', function() {
            this.setStyle(CONFIG.styles.routes);
          });
        }
      });
      // Layer NOT added to map by default - will show in PDF only

      // ========== OPPORTUNITY ZONES LAYER ==========
      featureLayers.zones = L.geoJSON(geoJsonData.zones, {
        style: CONFIG.styles.zones,
        onEachFeature: (feature, layer) => {
          const tractId = feature.properties.CENSUSTRAC || 'Unknown Tract';

          // Bind tooltip for hover info only (no click popup)
          layer.bindTooltip(`Census Tract ${tractId}`, {
            sticky: true,
            className: 'leaflet-tooltip'
          });

          // Hover effects
          layer.on('mouseover', function() {
            this.setStyle(CONFIG.styles.zonesHover);
          });

          layer.on('mouseout', function() {
            this.setStyle(CONFIG.styles.zones);
          });
        }
      });
      // Layer NOT added to map by default - will show in PDF only

      // ========== BRIDGES LAYER ==========
      featureLayers.bridges = L.geoJSON(geoJsonData.bridges, {
        pointToLayer: (feature, latlng) => {
          return L.circleMarker(latlng, CONFIG.styles.bridges);
        },
        onEachFeature: (feature, layer) => {
          const nbiId = feature.properties.STRUCTURE_ || 'Unknown';
          const condition = feature.properties.Condition || 'Unknown';

          // Bind tooltip for hover info only (no click popup)
          layer.bindTooltip(`NBI: ${nbiId} | Condition: ${condition}`, {
            sticky: true,
            className: 'leaflet-tooltip'
          });

          // Hover effects
          layer.on('mouseover', function() {
            this.setOptions(CONFIG.styles.bridgesHover);
          });

          layer.on('mouseout', function() {
            this.setOptions(CONFIG.styles.bridges);
          });
        }
      });
      // Layer NOT added to map by default - will show in PDF only

      // ========== LAYER CONTROL ==========
      const overlayLayers = {
        '<span style="color:#0066CC;">●</span> MATA Routes': featureLayers.routes,
        '<span style="color:#FFD700;">■</span> Opportunity Zones': featureLayers.zones,
        '<span style="color:#DC143C;">●</span> Bridges': featureLayers.bridges
      };

      L.control.layers(null, overlayLayers, {
        collapsed: false,
        position: 'topright'
      }).addTo(map);
    }

    /**
     * Calculate bounds from all data layers and fit map to show all features
     */
    function fitMapToBounds() {
      const bounds = L.latLngBounds([]);

      // Add bounds from all layers
      if (featureLayers.routes) bounds.extend(featureLayers.routes.getBounds());
      if (featureLayers.zones) bounds.extend(featureLayers.zones.getBounds());
      if (featureLayers.bridges) bounds.extend(featureLayers.bridges.getBounds());

      // Fit map to combined bounds with padding
      if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [50, 50] });
      }
    }

    // ============================================
    // DRAWING CONTROLS
    // ============================================

    /**
     * Set up Leaflet.draw controls for drawing project alignments
     * Only allows polyline drawing, one feature at a time
     */
    function setupDrawingControls() {
      // Create a feature group to store drawn items
      drawnItems = new L.FeatureGroup();
      map.addLayer(drawnItems);

      // Create draw handlers (but don't add toolbar to map)
      // These will be triggered programmatically from sidebar buttons
      polylineDrawer = new L.Draw.Polyline(map, {
        shapeOptions: CONFIG.styles.drawnLine,
        showLength: true,
        metric: false,  // Use imperial units (feet)
        feet: true
      });

      markerDrawer = new L.Draw.Marker(map, {
        icon: L.divIcon({
          className: 'project-marker',
          html: '<div style="background-color: #FF0000; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white;"></div>',
          iconSize: [30, 30],
          iconAnchor: [15, 15]
        })
      });

      // Event handler: When drawing is created
      map.on(L.Draw.Event.CREATED, function(event) {
        onDrawCreated(event, drawnItems);
      });

      // Event handler: When drawing starts
      map.on(L.Draw.Event.DRAWSTART, function() {
        updateDrawButtonStates(true);
      });

      // Event handler: When drawing stops
      map.on(L.Draw.Event.DRAWSTOP, function() {
        updateDrawButtonStates(false);
      });
    }

    // ============================================
    // EVENT HANDLERS
    // ============================================

    /**
     * Handle completion of drawing a project alignment or location
     * Validates geometry and triggers spatial analysis
     * @param {Object} event - Leaflet draw event
     * @param {L.FeatureGroup} drawnItems - Feature group containing drawn items
     */
    function onDrawCreated(event, drawnItems) {
      const layer = event.layer;

      // Remove any previous drawing
      if (drawnLayer) {
        map.removeLayer(drawnLayer);
        drawnItems.clearLayers();
      }

      // Add new drawing to map
      drawnLayer = layer;
      drawnItems.addLayer(layer);

      // Convert to GeoJSON for analysis
      drawnGeometry = layer.toGeoJSON();

      // Validate geometry
      if (!validateGeometry(drawnGeometry)) {
        const geomType = drawnGeometry.geometry.type;
        if (geomType === 'LineString') {
          showError(`Project alignment must be at least ${CONFIG.minLineLength} feet long.`);
        } else {
          showError('Invalid geometry drawn. Please try again.');
        }
        map.removeLayer(drawnLayer);
        drawnLayer = null;
        drawnGeometry = null;
        return;
      }

      // Run spatial analysis
      const results = analyzeIntersections(drawnGeometry);

      // Display results in sidebar
      displayResults(results);

      // Test Feature Service integration (if enabled)
      // This runs in the background and logs to console
      testFeatureServiceIntegration(drawnGeometry);

      // Show project name/PDF section
      document.getElementById('projectNameSection').classList.add('visible');

      // Focus project name input
      document.getElementById('projectName').focus();
    }

    /**
     * Handle clear button click
     * Removes drawn feature and resets results
     */
    function onClearClicked() {
      // Remove drawn layer from map
      if (drawnLayer) {
        map.removeLayer(drawnLayer);
        drawnLayer = null;
        drawnGeometry = null;
      }

      // Clear results
      clearResults();

      // Hide project name/PDF section
      document.getElementById('projectNameSection').classList.remove('visible');
    }

    /**
     * Handle PDF button click
     * Generates and downloads PDF report
     */
    async function onPDFButtonClicked() {
      await generatePDF();
    }

    /**
     * Handle project name input
     * Enables/disables PDF button based on input
     */
    function onProjectNameInput() {
      const projectName = document.getElementById('projectName').value.trim();
      const pdfButton = document.getElementById('pdfButton');

      // Enable PDF button only if project name is entered and we have results
      pdfButton.disabled = !projectName || !drawnGeometry;
    }

    /**
     * Handle draw line button click
     * Triggers polyline drawing mode
     */
    function onDrawLineButtonClicked() {
      // Disable marker drawing if active
      if (markerDrawer._enabled) {
        markerDrawer.disable();
      }

      // Toggle polyline drawing
      if (polylineDrawer._enabled) {
        polylineDrawer.disable();
      } else {
        polylineDrawer.enable();
      }
    }

    /**
     * Handle draw point button click
     * Triggers marker drawing mode
     */
    function onDrawPointButtonClicked() {
      // Disable polyline drawing if active
      if (polylineDrawer._enabled) {
        polylineDrawer.disable();
      }

      // Toggle marker drawing
      if (markerDrawer._enabled) {
        markerDrawer.disable();
      } else {
        markerDrawer.enable();
      }
    }

    /**
     * Update visual state of draw buttons
     * @param {boolean} isDrawing - Whether drawing is active
     */
    function updateDrawButtonStates(isDrawing) {
      const lineButton = document.getElementById('drawLineButton');
      const pointButton = document.getElementById('drawPointButton');

      if (isDrawing) {
        if (polylineDrawer._enabled) {
          lineButton.classList.add('active');
          pointButton.classList.remove('active');
        } else if (markerDrawer._enabled) {
          pointButton.classList.add('active');
          lineButton.classList.remove('active');
        }
      } else {
        lineButton.classList.remove('active');
        pointButton.classList.remove('active');
      }
    }

    /**
     * Set up all event listeners for the application
     */
    function setupEventListeners() {
      document.getElementById('clearButton').addEventListener('click', onClearClicked);
      document.getElementById('pdfButton').addEventListener('click', onPDFButtonClicked);
      document.getElementById('projectName').addEventListener('input', onProjectNameInput);
      document.getElementById('drawLineButton').addEventListener('click', onDrawLineButtonClicked);
      document.getElementById('drawPointButton').addEventListener('click', onDrawPointButtonClicked);
      document.getElementById('zoomExtentButton').addEventListener('click', fitMapToBounds);
      document.getElementById('tutorialCloseButton').addEventListener('click', closeTutorial);
      document.getElementById('tutorialOverlay').addEventListener('click', closeTutorial);
    }

    // ============================================
    // SPATIAL ANALYSIS
    // ============================================

    /**
     * Perform all spatial analyses on the drawn geometry
     * - Line-to-line intersections (or point-buffer intersections) with MATA routes
     * - Line-to-polygon intersections (or point-in-polygon) with opportunity zones
     * - Point-in-buffer proximity to bridges (300ft) for both lines and points
     * @param {Object} drawnGeometry - GeoJSON of drawn line or point
     * @returns {Object} Analysis results containing routes, zones, and bridges
     */
    function analyzeIntersections(drawnGeometry) {
      console.time('Spatial Analysis');

      const results = {
        routes: findIntersectingRoutes(drawnGeometry),
        zones: findIntersectingZones(drawnGeometry),
        bridges: findNearbyBridges(drawnGeometry)
      };

      console.timeEnd('Spatial Analysis');
      console.log('Analysis results:', results);

      // Store results globally
      currentResults = results;

      return results;
    }

    /**
     * Find all MATA routes that follow the same corridor as the drawn geometry
     * Routes must run parallel/along the project for at least 300ft (not just cross it)
     * For Points: Uses 300ft buffer around point to find nearby routes
     * Filters out directional suffixes (IB/OB/EB/WB) and deduplicates
     * @param {Object} featureOrGeometry - GeoJSON Feature or geometry (LineString or Point)
     * @returns {Array} Array of route names (cleaned and deduplicated)
     */
    function findIntersectingRoutes(featureOrGeometry) {
      const matchingRoutes = new Set();
      
      // Config for corridor matching
      const CORRIDOR_TOLERANCE = 100;  // feet - buffer for lines not touching exactly
      const MIN_SHARED_LENGTH = 300;   // feet - minimum parallel distance required

      // Extract actual geometry from GeoJSON Feature if needed
      const geometry = featureOrGeometry.type === 'Feature'
        ? featureOrGeometry.geometry
        : featureOrGeometry;

      // Create a buffer around the drawn geometry for tolerance
      const corridorBuffer = turf.buffer(geometry, CORRIDOR_TOLERANCE, {
        units: 'feet'
      });

      geoJsonData.routes.features.forEach(route => {
        try {
          let isMatch = false;

          if (geometry.type === 'LineString') {
            // Check if route has significant overlap within the corridor
            // First, see if route intersects the buffer at all
            if (turf.booleanIntersects(corridorBuffer, route)) {
              // Clip the route to the corridor buffer
              try {
                const clipped = turf.bboxClip(route, turf.bbox(corridorBuffer));
                
                // For more accurate clipping, use lineIntersect to find overlap
                // Then measure the length of route segments within the buffer
                const routeCoords = turf.getCoords(route);
                let overlapLength = 0;
                
                // Check each segment of the route
                for (let i = 0; i < routeCoords.length - 1; i++) {
                  const segment = turf.lineString([routeCoords[i], routeCoords[i + 1]]);
                  
                  // Check if segment midpoint is within the corridor buffer
                  const midpoint = turf.midpoint(
                    turf.point(routeCoords[i]), 
                    turf.point(routeCoords[i + 1])
                  );
                  
                  if (turf.booleanPointInPolygon(midpoint, corridorBuffer)) {
                    overlapLength += turf.length(segment, { units: 'feet' });
                  }
                }
                
                // Route matches if it has at least 300ft within the corridor
                isMatch = overlapLength >= MIN_SHARED_LENGTH;
                
              } catch (clipError) {
                // Fallback: if clipping fails, use simple intersection
                console.warn('Clip failed, using fallback:', clipError);
                isMatch = turf.booleanIntersects(corridorBuffer, route);
              }
            }
          } else if (geometry.type === 'Point') {
            // Point: buffer the point by 300ft and check if route intersects buffer
            const buffered = turf.buffer(geometry, CONFIG.bridgeBufferDistance, {
              units: CONFIG.bridgeBufferUnits
            });
            isMatch = turf.booleanIntersects(buffered, route);
          }

          if (isMatch) {
            const routeName = route.properties.Name || 'Unknown Route';
            // Clean the route name - remove directional suffixes
            const cleanedName = cleanRouteName(routeName);
            matchingRoutes.add(cleanedName);
          }
        } catch (error) {
          console.warn('Error checking route intersection:', error);
        }
      });

      // Convert Set to sorted array
      return Array.from(matchingRoutes).sort();
    }

    /**
     * Clean route name by removing directional suffixes (IB, OB, EB, WB)
     * @param {string} name - Original route name
     * @returns {string} Cleaned route name
     */
    function cleanRouteName(name) {
      if (!name) return 'Unknown Route';
      
      // Remove common directional suffixes (with optional space/dash before)
      // Handles: "Route 50 IB", "Route 50-OB", "Route 50IB", etc.
      return name
        .replace(/[\s\-]*(IB|OB|EB|WB)$/i, '')
        .trim();
    }

    /**
     * Find all opportunity zones that intersect the drawn geometry
     * For Lines: Uses Turf.js booleanIntersects for line-to-polygon intersection
     * For Points: Uses Turf.js booleanPointInPolygon to check if point is within zone
     * @param {Object} featureOrGeometry - GeoJSON Feature or geometry (LineString or Point)
     * @returns {Array} Array of census tract IDs
     */
    function findIntersectingZones(featureOrGeometry) {
      const intersectingZones = [];

      // Extract actual geometry from GeoJSON Feature if needed
      const geometry = featureOrGeometry.type === 'Feature'
        ? featureOrGeometry.geometry
        : featureOrGeometry;

      geoJsonData.zones.features.forEach(zone => {
        try {
          let intersects = false;

          if (geometry.type === 'LineString') {
            // Line-to-polygon intersection
            intersects = turf.booleanIntersects(geometry, zone);
          } else if (geometry.type === 'Point') {
            // Point-in-polygon check
            intersects = turf.booleanPointInPolygon(geometry, zone);
          }

          if (intersects) {
            const tractId = zone.properties.CENSUSTRAC || 'Unknown Tract';
            intersectingZones.push(tractId);
          }
        } catch (error) {
          console.warn('Error checking zone intersection:', error);
        }
      });

      // Sort by tract ID
      return intersectingZones.sort();
    }

    /**
     * Find all bridges within 300 feet of the drawn geometry
     * Creates a buffer around the line or point and checks point-in-polygon
     * @param {Object} featureOrGeometry - GeoJSON Feature or geometry (LineString or Point)
     * @returns {Array} Array of bridge objects {nbiId, condition}
     */
    function findNearbyBridges(featureOrGeometry) {
      const nearbyBridges = [];

      try {
        // Extract actual geometry from GeoJSON Feature if needed
        const geometry = featureOrGeometry.type === 'Feature'
          ? featureOrGeometry.geometry
          : featureOrGeometry;

        // Create 300-foot buffer around the drawn geometry (works for both lines and points)
        const buffered = turf.buffer(geometry, CONFIG.bridgeBufferDistance, {
          units: CONFIG.bridgeBufferUnits
        });

        // Check each bridge point against the buffer
        geoJsonData.bridges.features.forEach(bridge => {
          try {
            if (turf.booleanPointInPolygon(bridge, buffered)) {
              nearbyBridges.push({
                nbiId: bridge.properties.STRUCTURE_ || 'Unknown',
                condition: bridge.properties.Condition || 'Unknown'
              });
            }
          } catch (error) {
            console.warn('Error checking bridge proximity:', error);
          }
        });

        // Sort by NBI ID
        nearbyBridges.sort((a, b) => {
          return String(a.nbiId).localeCompare(String(b.nbiId));
        });

      } catch (error) {
        console.error('Error creating buffer or checking bridges:', error);
      }

      return nearbyBridges;
    }

    // ============================================
    // RESULTS DISPLAY
    // ============================================

    /**
     * Display analysis results in the sidebar
     * Updates routes list, zones list, and bridges table
     * @param {Object} results - Analysis results
     */
    function displayResults(results) {
      // Update count badges
      document.getElementById('routesCount').textContent = results.routes.length;
      document.getElementById('zonesCount').textContent = results.zones.length;
      document.getElementById('bridgesCount').textContent = results.bridges.length;

      // Display MATA Routes
      const routesList = document.getElementById('routesList');
      routesList.innerHTML = '';

      if (results.routes.length === 0) {
        routesList.innerHTML = '<li class="empty-state">No MATA routes intersected</li>';
      } else {
        results.routes.forEach(routeName => {
          const li = document.createElement('li');
          li.textContent = routeName;
          routesList.appendChild(li);
        });
      }

      // Display Opportunity Zones
      const zonesList = document.getElementById('zonesList');
      zonesList.innerHTML = '';

      if (results.zones.length === 0) {
        zonesList.innerHTML = '<li class="empty-state">No opportunity zones intersected</li>';
      } else {
        results.zones.forEach(tractId => {
          const li = document.createElement('li');
          li.textContent = `Census Tract ${tractId}`;
          zonesList.appendChild(li);
        });
      }

      // Display Bridges
      const bridgesContainer = document.getElementById('bridgesContainer');
      bridgesContainer.innerHTML = '';

      if (results.bridges.length === 0) {
        bridgesContainer.innerHTML = '<p class="empty-state">No bridges within 300 feet</p>';
      } else {
        // Create table
        const table = document.createElement('table');
        table.id = 'bridgesTable';

        // Table header
        const thead = document.createElement('thead');
        thead.innerHTML = `
          <tr>
            <th>NBI Structure ID</th>
            <th>Condition</th>
          </tr>
        `;
        table.appendChild(thead);

        // Table body
        const tbody = document.createElement('tbody');
        results.bridges.forEach(bridge => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${bridge.nbiId}</td>
            <td>${bridge.condition}</td>
          `;
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);

        bridgesContainer.appendChild(table);
      }

      // Enable PDF button if project name is entered
      onProjectNameInput();
    }

    /**
     * Clear all results from the sidebar
     * Resets to initial empty state
     */
    function clearResults() {
      // Reset count badges
      document.getElementById('routesCount').textContent = '0';
      document.getElementById('zonesCount').textContent = '0';
      document.getElementById('bridgesCount').textContent = '0';

      // Clear routes
      document.getElementById('routesList').innerHTML =
        '<li class="empty-state">Draw a project to see results</li>';

      // Clear zones
      document.getElementById('zonesList').innerHTML =
        '<li class="empty-state">Draw a project to see results</li>';

      // Clear bridges
      document.getElementById('bridgesContainer').innerHTML =
        '<p class="empty-state">Draw a project to see results</p>';

      // Clear project name
      document.getElementById('projectName').value = '';

      // Disable PDF button
      document.getElementById('pdfButton').disabled = true;

      // Clear stored results
      currentResults = { routes: [], zones: [], bridges: [] };
    }

    // ============================================
    // PDF GENERATION
    // ============================================

    /**
     * Generate and download PDF report
     * Captures map view, formats results, and creates downloadable PDF
     */
    async function generatePDF() {
      const projectName = document.getElementById('projectName').value.trim();

      // Validate project name
      if (!projectName) {
        showError('Please enter a project name before generating the PDF.');
        return;
      }

      // Track which layers were visible before PDF generation
      const layerStates = {
        routes: map.hasLayer(featureLayers.routes),
        zones: map.hasLayer(featureLayers.zones),
        bridges: map.hasLayer(featureLayers.bridges)
      };

      try {
        // Disable button and show loading state
        const pdfButton = document.getElementById('pdfButton');
        const originalText = pdfButton.textContent;
        pdfButton.disabled = true;
        pdfButton.textContent = 'Generating PDF...';

        // Show loading overlay with PDF progress
        showLoading(true, 'Preparing map for PDF...');

        // Temporarily add all reference layers to map for PDF capture
        if (!layerStates.routes) map.addLayer(featureLayers.routes);
        if (!layerStates.zones) map.addLayer(featureLayers.zones);
        if (!layerStates.bridges) map.addLayer(featureLayers.bridges);

        // Auto-zoom map to show drawn line and intersecting features
        // Use animate: false to ensure immediate positioning
        const optimalBounds = getOptimalMapBounds();
        if (optimalBounds) {
          map.fitBounds(optimalBounds, {
            padding: [80, 80],  // Increased padding for better centering
            maxZoom: 16,        // Prevent zooming in too close
            animate: false      // Critical: prevents capture during animation
          });
        }

        // Wait for map tiles to load before capturing
        showLoading(true, 'Loading map tiles...');
        await waitForTilesToLoad();

        // Additional buffer for any remaining rendering
        await new Promise(resolve => setTimeout(resolve, 300));

        showLoading(true, 'Capturing map image...');

        // Capture map as image using html2canvas
        const mapElement = document.getElementById('map');
        const canvas = await html2canvas(mapElement, {
          useCORS: true,
          allowTaint: true,
          scale: 2,  // Higher DPI for better quality
          logging: false,
          backgroundColor: '#ffffff',
          // Ensure we capture all layers
          onclone: function(clonedDoc) {
            // Force all Leaflet panes to be visible in clone
            const panes = clonedDoc.querySelectorAll('.leaflet-pane');
            panes.forEach(pane => {
              pane.style.opacity = '1';
              pane.style.visibility = 'visible';
            });
          }
        });

        // Restore layer visibility to previous state
        if (!layerStates.routes) map.removeLayer(featureLayers.routes);
        if (!layerStates.zones) map.removeLayer(featureLayers.zones);
        if (!layerStates.bridges) map.removeLayer(featureLayers.bridges);

        showLoading(true, 'Building PDF document...');

        const mapImageData = canvas.toDataURL('image/png');

        // Create PDF using jsPDF
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: 'portrait',
          unit: 'in',
          format: 'letter'  // 8.5 x 11 inches
        });

        // PDF dimensions (letter size with margins)
        const pageWidth = 8.5;
        const pageHeight = 11;
        const margin = 0.5;
        const contentWidth = pageWidth - (2 * margin);

        let yPosition = margin;

        // ========== HEADER SECTION ==========

        // Add logo (if available)
        try {
          // Note: For production, you may need to convert logo to base64
          // Project name as main title
          pdf.setFontSize(18);
          pdf.setFont('helvetica', 'bold');
          pdf.text(projectName, pageWidth / 2, yPosition, { align: 'center' });
          yPosition += 0.3;
        } catch (error) {
          console.warn('Could not add logo to PDF:', error);
        }

        // Project Application Report as subtitle
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'normal');
        pdf.text('Project Application Report', pageWidth / 2, yPosition, { align: 'center' });
        yPosition += 0.3;

        // Date generated
        pdf.setFontSize(10);
        pdf.setTextColor(128, 128, 128);
        const currentDate = new Date().toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
        pdf.text(`Generated: ${currentDate}`, pageWidth - margin, yPosition, { align: 'right' });
        yPosition += 0.2;

        // Project length (only for line features)
        if (drawnGeometry && drawnGeometry.geometry && drawnGeometry.geometry.type === 'LineString') {
          const lengthInMiles = turf.length(drawnGeometry.geometry, { units: 'miles' });
          pdf.text(`Project Length: ${lengthInMiles.toFixed(1)} miles`, pageWidth - margin, yPosition, { align: 'right' });
        }

        pdf.setTextColor(0, 0, 0);
        yPosition += 0.5;

        // ========== MAP SECTION ==========

        // Add map image
        const mapWidth = 7;
        const mapHeight = (canvas.height / canvas.width) * mapWidth;
        const mapX = (pageWidth - mapWidth) / 2;

        pdf.addImage(mapImageData, 'PNG', mapX, yPosition, mapWidth, mapHeight);
        yPosition += mapHeight + 0.4;

        // ========== RESULTS SECTION ==========
        // Only include sections that have results

        const hasAnyResults = currentResults.routes.length > 0 || 
                              currentResults.zones.length > 0 || 
                              currentResults.bridges.length > 0;

        // Helper function to check if we need a new page
        const checkPageBreak = (neededSpace = 0.5) => {
          const footerSpace = 0.5;
          if (yPosition + neededSpace > pageHeight - footerSpace) {
            pdf.addPage();
            yPosition = margin;
            return true;
          }
          return false;
        };

        if (hasAnyResults) {
          checkPageBreak(0.5);
          pdf.setFontSize(12);
          pdf.setFont('helvetica', 'bold');
          pdf.text('Analysis Results', margin, yPosition);
          yPosition += 0.3;
        }

        // MATA Routes - only if results exist
        if (currentResults.routes.length > 0) {
          checkPageBreak(0.5);
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'bold');
          pdf.text('MATA Routes:', margin, yPosition);
          yPosition += 0.2;
          pdf.setFontSize(10);
          pdf.setFont('helvetica', 'normal');

          currentResults.routes.forEach(route => {
            checkPageBreak(0.2);
            pdf.text(`  • ${route}`, margin, yPosition);
            yPosition += 0.18;
          });
          yPosition += 0.15;
        }

        // Opportunity Zones - only if results exist
        if (currentResults.zones.length > 0) {
          checkPageBreak(0.5);
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'bold');
          pdf.text('Opportunity Zones:', margin, yPosition);
          yPosition += 0.2;
          pdf.setFontSize(10);
          pdf.setFont('helvetica', 'normal');

          currentResults.zones.forEach(zone => {
            checkPageBreak(0.2);
            pdf.text(`  • Census Tract ${zone}`, margin, yPosition);
            yPosition += 0.18;
          });
          yPosition += 0.15;
        }

        // Bridges - only if results exist
        if (currentResults.bridges.length > 0) {
          checkPageBreak(0.6);
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'bold');
          pdf.text('Bridges:', margin, yPosition);
          yPosition += 0.2;
          pdf.setFontSize(10);

          // Table header
          pdf.setFont('helvetica', 'bold');
          pdf.text('NBI Structure ID', margin + 0.2, yPosition);
          pdf.text('Condition', margin + 3, yPosition);
          yPosition += 0.18;
          pdf.setFont('helvetica', 'normal');

          currentResults.bridges.forEach(bridge => {
            checkPageBreak(0.2);
            pdf.text(String(bridge.nbiId), margin + 0.2, yPosition);
            pdf.text(String(bridge.condition), margin + 3, yPosition);
            yPosition += 0.15;
          });
        }

        // ========== FOOTER (on each page) ==========
        const totalPages = pdf.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
          pdf.setPage(i);
          pdf.setFontSize(8);
          pdf.setTextColor(128, 128, 128);
          const footerY = pageHeight - 0.3;
          pdf.text('Generated by Memphis MPO Project Application Tool', pageWidth / 2, footerY, { align: 'center' });
          if (totalPages > 1) {
            pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin, footerY, { align: 'right' });
          }
        }

        // ========== SAVE PDF ==========

        const fileName = formatFileName(projectName);
        pdf.save(fileName);

        // Hide loading overlay
        showLoading(false);

        // Re-enable button
        pdfButton.disabled = false;
        pdfButton.textContent = originalText;

      } catch (error) {
        console.error('PDF generation error:', error);
        
        // Restore layer visibility to previous state on error
        if (!layerStates.routes && map.hasLayer(featureLayers.routes)) {
          map.removeLayer(featureLayers.routes);
        }
        if (!layerStates.zones && map.hasLayer(featureLayers.zones)) {
          map.removeLayer(featureLayers.zones);
        }
        if (!layerStates.bridges && map.hasLayer(featureLayers.bridges)) {
          map.removeLayer(featureLayers.bridges);
        }

        showLoading(false);
        showError('Failed to generate PDF. Please try again.');

        // Re-enable button
        const pdfButton = document.getElementById('pdfButton');
        pdfButton.disabled = false;
        pdfButton.textContent = 'Download PDF Report';
      }
    }

    /**
     * Calculate optimal map bounds to show drawn geometry
     * Focuses on the project area only, not entire intersecting features
     * Ensures the project is centered in the map view
     * @returns {L.LatLngBounds} Bounds object for map fitting
     */
    function getOptimalMapBounds() {
      if (!drawnLayer) return null;

      // Handle different layer types
      if (drawnLayer.getBounds) {
        // LineString - has getBounds method
        const lineBounds = drawnLayer.getBounds();
        const center = lineBounds.getCenter();
        const latDiff = Math.abs(lineBounds.getNorth() - lineBounds.getSouth());
        const lngDiff = Math.abs(lineBounds.getEast() - lineBounds.getWest());

        // Expand bounds evenly around center by 50% on each side for better framing
        const latPad = latDiff * 0.5;
        const lngPad = lngDiff * 0.5;

        // Create new bounds centered on the project center
        return L.latLngBounds([
          [center.lat - latDiff / 2 - latPad, center.lng - lngDiff / 2 - lngPad],
          [center.lat + latDiff / 2 + latPad, center.lng + lngDiff / 2 + lngPad]
        ]);
      } else if (drawnLayer.getLatLng) {
        // Point/Marker - use getLatLng
        const latlng = drawnLayer.getLatLng();
        // Create balanced bounds around the point (0.008 degrees ~ 800m for better framing)
        const offset = 0.008;
        return L.latLngBounds([
          [latlng.lat - offset, latlng.lng - offset],
          [latlng.lat + offset, latlng.lng + offset]
        ]);
      }

      return null;
    }

    /**
     * Format project name into valid filename for PDF download
     * Replaces spaces with underscores and adds ISO date
     * @param {string} projectName - User-entered project name
     * @returns {string} Formatted filename
     */
    function formatFileName(projectName) {
      // Replace spaces and special characters with underscores
      const sanitized = projectName.replace(/[^a-zA-Z0-9]/g, '_');

      // Get current date in YYYY-MM-DD format
      const date = new Date();
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;

      return `Project_Application_${sanitized}_${dateStr}.pdf`;
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    /**
     * Wait for all map tiles to finish loading
     * Returns a promise that resolves when tiles are loaded
     * @returns {Promise} Resolves when tiles are loaded or after timeout
     */
    function waitForTilesToLoad() {
      return new Promise((resolve) => {
        // Get the tile layer from map
        let tileLayer = null;
        map.eachLayer(layer => {
          if (layer instanceof L.TileLayer) {
            tileLayer = layer;
          }
        });

        if (!tileLayer) {
          // No tile layer found, resolve immediately
          resolve();
          return;
        }

        // Check if tiles are already loaded
        let pendingTiles = 0;
        const container = tileLayer.getContainer();
        if (container) {
          const tiles = container.querySelectorAll('img');
          tiles.forEach(tile => {
            if (!tile.complete) pendingTiles++;
          });
        }

        if (pendingTiles === 0) {
          // All tiles already loaded
          resolve();
          return;
        }

        // Wait for 'load' event or timeout
        let resolved = false;
        
        const onLoad = () => {
          if (!resolved) {
            resolved = true;
            tileLayer.off('load', onLoad);
            resolve();
          }
        };

        tileLayer.on('load', onLoad);

        // Timeout fallback (3 seconds max wait)
        setTimeout(() => {
          if (!resolved) {
            resolved = true;
            tileLayer.off('load', onLoad);
            console.warn('Tile load timeout - proceeding with capture');
            resolve();
          }
        }, 3000);
      });
    }

    /**
     * Validate drawn geometry meets minimum length requirement
     * For LineStrings: Uses Turf.js to calculate line length in feet
     * For Points: Always valid (no length requirement)
     * @param {Object} featureOrGeometry - GeoJSON Feature or geometry object
     * @returns {boolean} True if valid, false otherwise
     */
    function validateGeometry(featureOrGeometry) {
      try {
        // Extract actual geometry from GeoJSON Feature if needed
        const geometry = featureOrGeometry.type === 'Feature'
          ? featureOrGeometry.geometry
          : featureOrGeometry;

        console.log('Validating geometry type:', geometry.type);

        // Points are always valid
        if (geometry.type === 'Point') {
          console.log('Point geometry detected - validation passed');
          return true;
        }

        // For LineStrings, check minimum length
        if (geometry.type === 'LineString') {
          const length = turf.length(geometry, { units: 'feet' });
          console.log(`Drawn line length: ${length.toFixed(2)} feet`);
          return length >= CONFIG.minLineLength;
        }

        // Unknown geometry type
        console.warn('Unknown geometry type:', geometry.type);
        return false;
      } catch (error) {
        console.error('Geometry validation error:', error);
        return false;
      }
    }

    /**
     * Show user-friendly error message
     * @param {string} message - Error message to display
     */
    function showError(message) {
      alert(message);
    }

    /**
     * Show or hide loading overlay
     * @param {boolean} show - Whether to show or hide the overlay
     * @param {string} message - Optional loading message
     */
    function showLoading(show, message = 'Loading...') {
      const overlay = document.getElementById('loadingOverlay');
      const loadingText = document.getElementById('loadingText');

      if (show) {
        loadingText.textContent = message;
        overlay.style.display = 'flex';
      } else {
        overlay.style.display = 'none';
      }
    }

    // ============================================
    // START APPLICATION
    // ============================================

    // Initialize application when DOM is fully loaded
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
