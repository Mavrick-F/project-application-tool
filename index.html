<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Memphis MPO - Project Application Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Leaflet CSS for map rendering -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>

  <!-- Leaflet Draw CSS for drawing tools -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

  <style>
    /* ============================================
       RESET & BASE STYLES
       ============================================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
      font-size: 14px;
      line-height: 1.5;
      color: #333333;
      background-color: #ffffff;
      overflow: hidden;
    }

    /* ============================================
       LAYOUT
       ============================================ */
    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    /* Top header bar */
    header {
      display: flex;
      align-items: center;
      padding: 15px 20px;
      background-color: #1565C0;
      color: white;
      min-height: 80px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    header img {
      height: 60px;
      max-width: 200px;
      margin-right: 20px;
      object-fit: contain;
    }

    header h1 {
      font-size: 20px;
      font-weight: bold;
    }

    /* Main container with sidebar and map */
    #container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Left sidebar for results */
    #sidebar {
      width: 350px;
      background-color: #F5F5F5;
      overflow-y: auto;
      padding: 20px;
      border-right: 1px solid #CCCCCC;
    }

    /* Map container */
    #map {
      flex: 1;
      position: relative;
    }

    /* ============================================
       SIDEBAR COMPONENTS
       ============================================ */
    .sidebar-section {
      margin-bottom: 25px;
    }

    .section-heading {
      font-size: 16px;
      font-weight: bold;
      color: #1565C0;
      margin-bottom: 10px;
      text-transform: uppercase;
    }

    .divider {
      height: 1px;
      background-color: #CCCCCC;
      margin: 20px 0;
    }

    /* Project name input */
    #projectName {
      width: 100%;
      padding: 10px;
      border: 1px solid #CCCCCC;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
    }

    #projectName:focus {
      outline: none;
      border-color: #1565C0;
      box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.1);
    }

    /* Project name section - hidden until drawing complete */
    #projectNameSection {
      display: none;
    }

    #projectNameSection.visible {
      display: block;
    }

    /* Results lists */
    .results-list {
      list-style: none;
      padding-left: 0;
    }

    .results-list li {
      padding: 5px 0;
      padding-left: 15px;
      position: relative;
    }

    .results-list li:before {
      content: "•";
      position: absolute;
      left: 0;
      color: #1565C0;
      font-weight: bold;
    }

    .empty-state {
      color: #666666;
      font-style: italic;
      padding: 5px 0;
    }

    /* Results card styling */
    .results-card {
      background-color: white;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 15px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.08);
      border-left: 3px solid #1565C0;
    }

    .results-card.routes { border-left-color: #0066CC; }
    .results-card.zones { border-left-color: #FF8C00; }
    .results-card.bridges { border-left-color: #DC143C; }

    .results-card .section-heading {
      margin-bottom: 8px;
      font-size: 14px;
    }

    .result-count {
      display: inline-block;
      background-color: #E3F2FD;
      color: #1565C0;
      font-size: 11px;
      font-weight: bold;
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: 8px;
    }

    .results-card.routes .result-count { background-color: #E3F2FD; color: #0066CC; }
    .results-card.zones .result-count { background-color: #FFF3E0; color: #E65100; }
    .results-card.bridges .result-count { background-color: #FFEBEE; color: #C62828; }

    /* Bridges table */
    #bridgesTable {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      background-color: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    #bridgesTable th {
      background-color: #E6F2FF;
      padding: 10px;
      text-align: left;
      font-weight: bold;
      border: 1px solid #CCCCCC;
      font-size: 12px;
    }

    #bridgesTable td {
      padding: 8px 10px;
      border: 1px solid #CCCCCC;
      font-size: 12px;
    }

    #bridgesTable tr:nth-child(even) {
      background-color: #F9F9F9;
    }

    /* Buttons */
    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s;
      font-family: inherit;
    }

    .btn-primary {
      background-color: #1565C0;
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      background-color: #0D47A1;
    }

    .btn-primary:disabled {
      background-color: #CCCCCC;
      cursor: not-allowed;
    }

    .btn-secondary {
      background-color: #666666;
      color: white;
      margin-top: 10px;
    }

    .btn-secondary:hover {
      background-color: #444444;
    }

    .btn-draw {
      background-color: #1565C0;
      color: white;
      margin-bottom: 10px;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: left;
    }

    .btn-draw:hover {
      background-color: #0D47A1;
    }

    .btn-draw.active {
      background-color: #43A047;
      box-shadow: 0 0 0 3px rgba(67, 160, 71, 0.3);
    }

    .btn-draw.active:hover {
      background-color: #2E7D32;
    }

    /* Helper text */
    .helper-text {
      font-size: 12px;
      color: #666666;
      margin-top: 5px;
    }

    /* ============================================
       LOADING OVERLAY
       ============================================ */
    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #004C97;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #loadingText {
      margin-top: 20px;
      font-size: 16px;
      color: #333333;
    }

    /* ============================================
       RESPONSIVE WARNING
       ============================================ */
    #mobileWarning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
      z-index: 10000;
    }

    @media (max-width: 1024px) {
      #mobileWarning {
        display: flex;
      }

      #app {
        display: none;
      }
    }

    /* ============================================
       LEAFLET CUSTOMIZATIONS
       ============================================ */
    .leaflet-draw-toolbar a {
      background-color: #1565C0;
    }

    .leaflet-draw-draw-polyline {
      background-color: #1565C0;
    }

    /* Custom tooltip styling */
    .leaflet-tooltip {
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 6px 10px;
      font-size: 12px;
    }

    /* Layer control styling */
    .leaflet-control-layers {
      background-color: white;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      padding: 8px 12px;
    }

    .leaflet-control-layers-list {
      font-size: 13px;
    }

    .leaflet-control-layers label {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 4px 0;
      cursor: pointer;
    }

    .leaflet-control-layers-overlays {
      padding-top: 5px;
    }

    /* Scale control styling */
    .leaflet-control-scale-line {
      background-color: rgba(255,255,255,0.8);
      border: 1px solid #666;
      border-top: none;
      font-size: 11px;
      padding: 2px 5px;
    }

    /* ============================================
       TUTORIAL POPUP
       ============================================ */
    #tutorialPopup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      padding: 30px;
      max-width: 500px;
      z-index: 10001;
      display: none;
    }

    #tutorialPopup.visible {
      display: block;
    }

    #tutorialOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      display: none;
    }

    #tutorialOverlay.visible {
      display: block;
    }

    #tutorialPopup h2 {
      margin: 0 0 20px 0;
      color: #1565C0;
      font-size: 22px;
      font-weight: bold;
    }

    #tutorialPopup ul {
      list-style: none;
      padding: 0;
      margin: 0 0 25px 0;
    }

    #tutorialPopup li {
      padding: 12px 0 12px 30px;
      position: relative;
      line-height: 1.6;
      color: #333;
      font-size: 15px;
    }

    #tutorialPopup li:before {
      content: "✓";
      position: absolute;
      left: 0;
      color: #1565C0;
      font-weight: bold;
      font-size: 18px;
    }

    #tutorialPopup .tutorial-close {
      width: 100%;
      padding: 12px;
      background-color: #1565C0;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 15px;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    #tutorialPopup .tutorial-close:hover {
      background-color: #0D47A1;
    }
  </style>
</head>
<body>
  <!-- Mobile/small screen warning -->
  <div id="mobileWarning">
    <div>
      <h2>Desktop Browser Required</h2>
      <p>This tool requires a desktop browser with a minimum width of 1024px.</p>
    </div>
  </div>

  <!-- Main application -->
  <div id="app">
    <!-- Header -->
    <header>
      <img src="./assets/rtp-2055-logo.jpg" alt="RTP 2055 Logo">
      <h1>Project Application Tool</h1>
    </header>

    <!-- Main container -->
    <div id="container">
      <!-- Sidebar -->
      <aside id="sidebar">
        <div class="sidebar-section">
          <div class="section-heading">Draw Your Project</div>
          <button class="btn btn-draw" id="drawLineButton">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
              <line x1="5" y1="19" x2="19" y2="5"></line>
              <circle cx="5" cy="19" r="2"></circle>
              <circle cx="19" cy="5" r="2"></circle>
            </svg>
            Draw Alignment (Line)
          </button>
          <button class="btn btn-draw" id="drawPointButton">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
              <circle cx="12" cy="10" r="3"></circle>
            </svg>
            Mark Location (Point)
          </button>
          <div class="helper-text">Choose line for corridor projects or point for specific locations</div>
          <button class="btn btn-secondary" id="zoomExtentButton" style="margin-top: 10px; display: flex; align-items: center; justify-content: center;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px;">
              <rect x="3" y="3" width="18" height="18" rx="2"></rect>
              <path d="M9 3v18M15 3v18M3 9h18M3 15h18"></path>
            </svg>
            Zoom to Full Extent
          </button>
        </div>

        <div class="divider"></div>

        <!-- Project name and PDF section - hidden until drawing complete -->
        <div id="projectNameSection">
          <div class="sidebar-section">
            <div class="section-heading">Generate Report</div>
            <label for="projectName" style="font-size: 13px; color: #666; margin-bottom: 5px; display: block;">Project Name</label>
            <input
              type="text"
              id="projectName"
              placeholder="Enter project name..."
              aria-label="Project Name"
            >
            <div class="helper-text" style="margin-bottom: 15px;">Required for PDF report</div>

            <button class="btn btn-primary" id="pdfButton" disabled>
              Download PDF Report
            </button>

            <button class="btn btn-secondary" id="clearButton">
              Clear & Start Over
            </button>
          </div>

          <div class="divider"></div>
        </div>

        <div class="sidebar-section">
          <div class="section-heading">Analysis Results</div>

          <!-- Dynamic results container - populated by JavaScript -->
          <div id="resultsContainer">
            <div style="padding: 20px; text-align: center; color: #666;">
              <p style="font-size: 16px; margin: 0;">Draw a project to see analysis results</p>
              <p style="font-size: 13px; margin-top: 10px; color: #999;">Click "Draw Alignment" or "Mark Location" above to get started</p>
            </div>
          </div>
        </div>
      </aside>

      <!-- Map -->
      <div id="map"></div>
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div id="loadingText">Loading map data...</div>
  </div>

  <!-- Tutorial popup -->
  <div id="tutorialOverlay"></div>
  <div id="tutorialPopup">
    <h2>Welcome to the Project Application Tool</h2>
    <ul>
      <li>Draw a line for corridor projects OR a point for intersection/spot improvements</li>
      <li>Your line will find routes running parallel for at least 300ft</li>
      <li>Results auto-update when you finish drawing</li>
    </ul>
    <button class="tutorial-close" id="tutorialCloseButton">Got it!</button>
  </div>

  <!-- CDN Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <script>
    // ============================================
    // CONFIGURATION
    // ============================================
    const CONFIG = {
      // Spatial analysis parameters
      bridgeBufferDistance: 300,      // Buffer distance in feet for bridge proximity
      bridgeBufferUnits: 'feet',      // Units for buffer calculation
      minLineLength: 100,             // Minimum project length in feet

      // Map configuration
      mapCenter: null,                // Auto-calculated from data bounds
      mapZoom: 11,                    // Default zoom level
      basemapUrl: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
      basemapAttribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',

      // Drawn geometry style
      drawnLineStyle: {
        color: '#FF0000',
        weight: 8,
        opacity: 0.8
      },

      // Logo path
      logoPath: './assets/rtp-2055-logo.jpg'
    };

    // ============================================
    // DATASET CONFIGURATION
    // ============================================
    /**
     * Configuration object for all datasets in the application
     * Each dataset defines its file path, geometry type, analysis method,
     * display properties, and styling options
     */
    const DATASETS = {
      mataRoutes: {
        id: 'mataRoutes',
        name: 'MATA Routes',
        category: 'Transportation - Transit',
        filePath: './data/mata-routes.json',
        geometryType: 'LineString',
        analysisMethod: 'corridor',
        bufferDistance: 100,
        minSharedLength: 300,
        proximityBuffer: null,
        properties: {
          displayField: 'Name',
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: true,
          deduplicate: true
        },
        style: {
          color: '#0066CC',
          weight: 2,
          opacity: 0.7
        },
        resultStyle: 'list',
        enabled: true
      },

      strahnet: {
        id: 'strahnet',
        name: 'STRAHNET Routes',
        category: 'Transportation - Freight',
        filePath: './data/strahnet.geojson',
        geometryType: 'LineString',
        analysisMethod: 'corridor',
        bufferDistance: 100,
        minSharedLength: 300,
        proximityBuffer: null,
        properties: {
          displayField: 'OBJECTID',
          staticLabel: 'STRAHNET',  // Show static label instead of field value
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#FF6600',
          weight: 3,
          opacity: 0.8
        },
        resultStyle: 'list',
        enabled: true
      },

      truckRoutes: {
        id: 'truckRoutes',
        name: 'MPO Freight Route Network',
        category: 'Transportation - Freight',
        filePath: './data/truck_routes.json',
        geometryType: 'LineString',
        analysisMethod: 'corridor',
        bufferDistance: 100,
        minSharedLength: 300,
        proximityBuffer: null,
        properties: {
          displayField: 'Type',  // Show Regional or Local
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#CC6600',  // Default color, overridden by styleByProperty
          weight: 2,
          opacity: 0.7
        },
        styleByProperty: {  // Different colors for Regional vs Local
          field: 'Type',
          values: {
            'Regional': { color: '#CC0000', weight: 3, opacity: 0.8 },  // Red for Regional
            'Local': { color: '#FF9900', weight: 2, opacity: 0.7 }       // Orange for Local
          }
        },
        resultStyle: 'list',
        enabled: true
      },

      opportunityZones: {
        id: 'opportunityZones',
        name: 'Opportunity Zones',
        category: 'Economic Development',
        filePath: './data/opportunity-zones.json',
        geometryType: 'Polygon',
        analysisMethod: 'intersection',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: null,
        properties: {
          displayField: 'CENSUSTRAC',
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#FF8C00',
          weight: 2,
          fillColor: '#FFD700',
          fillOpacity: 0.3
        },
        resultStyle: 'list',
        enabled: true
      },

      freightClusters: {
        id: 'freightClusters',
        name: 'MPO Freight Zones',
        category: 'Transportation - Freight',
        filePath: './data/freight_clusters.geojson',
        geometryType: 'Polygon',
        analysisMethod: 'intersection',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: null,
        properties: {
          displayField: 'N',
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#9966CC',
          weight: 2,
          fillColor: '#CC99FF',
          fillOpacity: 0.3
        },
        resultStyle: 'list',
        enabled: true
      },

      parks: {
        id: 'parks',
        name: 'Parks',
        category: 'Environment & Recreation',
        filePath: './data/parks.json',
        geometryType: 'Polygon',
        analysisMethod: 'proximity',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: 200,
        properties: {
          displayField: 'NAME',
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#228B22',
          weight: 2,
          fillColor: '#90EE90',
          fillOpacity: 0.3
        },
        resultStyle: 'list',
        enabled: true
      },

      historicPolygons: {
        id: 'historicPolygons',
        name: 'NHRP Polygons',
        category: 'Historic & Cultural',
        filePath: './data/historic_polygons.geojson',
        geometryType: 'Polygon',
        analysisMethod: 'proximity',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: 200,
        properties: {
          displayField: 'RESNAME',
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#8B4513',
          weight: 2,
          fillColor: '#DEB887',
          fillOpacity: 0.3
        },
        resultStyle: 'list',
        enabled: true
      },

      bridges: {
        id: 'bridges',
        name: 'Bridges',
        category: 'Infrastructure',
        filePath: './data/bridges.json',
        geometryType: 'Point',
        analysisMethod: 'proximity',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: 300,
        properties: {
          displayField: 'STRUCTURE_',
          additionalFields: ['Condition']
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#DC143C',
          fillColor: '#DC143C',
          radius: 3,
          fillOpacity: 0.8,
          weight: 1
        },
        resultStyle: 'table',
        enabled: true
      },

      majorEmployers: {
        id: 'majorEmployers',
        name: 'Major Employers',
        category: 'Economic Development',
        filePath: './data/major_employers.geojson',
        geometryType: 'Point',
        analysisMethod: 'proximity',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: 1320,
        properties: {
          displayField: 'company_name',
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#4169E1',
          fillColor: '#4169E1',
          radius: 4,
          fillOpacity: 0.8,
          weight: 1
        },
        resultStyle: 'list',
        enabled: true
      },

      touristAttractions: {
        id: 'touristAttractions',
        name: 'Tourist Destinations',
        category: 'Economic Development',
        filePath: './data/tourist_attractions.geojson',
        geometryType: 'Point',
        analysisMethod: 'proximity',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: 1320,
        properties: {
          displayField: 'NAME',  // Use correct uppercase field name
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#FF1493',
          fillColor: '#FF1493',
          radius: 4,
          fillOpacity: 0.8,
          weight: 1
        },
        resultStyle: 'list',
        enabled: true
      },

      historicPoints: {
        id: 'historicPoints',
        name: 'NHRP Points',
        category: 'Historic & Cultural',
        filePath: './data/historic_points.geojson',
        geometryType: 'Point',
        analysisMethod: 'proximity',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: 200,
        properties: {
          displayField: 'RESNAME',
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#8B4513',
          fillColor: '#8B4513',
          radius: 3,
          fillOpacity: 0.8,
          weight: 1
        },
        resultStyle: 'list',
        enabled: true
      },

      epaSuperFundSites: {
        id: 'epaSuperFundSites',
        name: 'EPA Superfund Sites',
        category: 'Environment & Recreation',
        filePath: './data/epa_superfund_sites.geojson',
        geometryType: 'Point',
        analysisMethod: 'proximity',
        bufferDistance: null,
        minSharedLength: null,
        proximityBuffer: 200,
        properties: {
          displayField: 'PRIMARY_NAME',  // Use correct field name
          additionalFields: []
        },
        specialHandling: {
          removeDirectionalSuffixes: false,
          deduplicate: false
        },
        style: {
          color: '#FF4500',
          fillColor: '#FF4500',
          radius: 4,
          fillOpacity: 0.8,
          weight: 1
        },
        resultStyle: 'list',
        enabled: true
      }
    };

    // ============================================
    // GLOBAL STATE
    // ============================================
    let map;                          // Leaflet map instance
    let drawControl;                  // Leaflet.draw control
    let drawnLayer = null;            // Currently drawn polyline layer
    let drawnGeometry = null;         // GeoJSON of drawn line
    let drawnItems;                   // Feature group for drawn items
    let polylineDrawer;               // Polyline draw handler
    let markerDrawer;                 // Marker draw handler

    // Layer groups for reference data (dynamically populated from DATASETS)
    let featureLayers = {};

    // Raw GeoJSON data (dynamically populated from DATASETS)
    let geoJsonData = {};

    // Analysis results (dynamically populated from DATASETS)
    let currentResults = {};

    // ============================================
    // INITIALIZATION
    // ============================================

    /**
     * Initialize the application
     * - Loads all GeoJSON data
     * - Initializes the map
     * - Sets up drawing controls
     * - Configures event listeners
     */
    async function init() {
      try {
        showLoading(true, 'Loading map data...');

        // Load all GeoJSON files
        await loadGeoJsonData();

        // Initialize the Leaflet map
        initializeMap();

        // Add reference layers to map
        addReferenceLayers();

        // Calculate and fit map to data bounds
        fitMapToBounds();

        // Set up drawing controls
        setupDrawingControls();

        // Set up event listeners
        setupEventListeners();

        // Hide loading overlay
        showLoading(false);

        // Show tutorial popup if first visit
        showTutorialIfFirstVisit();

      } catch (error) {
        console.error('Initialization error:', error);
        showError('Failed to initialize the application. Please refresh the page.');
      }
    }

    /**
     * Show tutorial popup on first visit
     * Uses localStorage to track if user has seen the tutorial
     */
    function showTutorialIfFirstVisit() {
      const hasSeenTutorial = localStorage.getItem('hasSeenTutorial');

      if (!hasSeenTutorial) {
        // Show tutorial popup
        document.getElementById('tutorialOverlay').classList.add('visible');
        document.getElementById('tutorialPopup').classList.add('visible');
      }
    }

    /**
     * Close tutorial popup and mark as seen
     */
    function closeTutorial() {
      document.getElementById('tutorialOverlay').classList.remove('visible');
      document.getElementById('tutorialPopup').classList.remove('visible');
      localStorage.setItem('hasSeenTutorial', 'true');
    }

    // ============================================
    // FEATURE SERVICE QUERY
    // ============================================

    /**
     * Discover the correct layer from a FeatureServer by querying its metadata
     * @param {string} serviceUrl - The base FeatureServer URL (without /N at the end)
     * @param {Object} options - Discovery options
     * @param {string} options.layerName - Optional layer name to match (case-insensitive)
     * @returns {Promise<Object>} - Object with {layerIndex, layerInfo} or null if not found
     */
    async function discoverFeatureServiceLayer(serviceUrl, options = {}) {
      try {
        // Remove trailing slash if present
        const baseUrl = serviceUrl.replace(/\/$/, '');

        // Query the service metadata
        const metadataUrl = `${baseUrl}?f=json`;
        console.log('Fetching service metadata from:', metadataUrl);

        const response = await fetch(metadataUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch service metadata: ${response.status} ${response.statusText}`);
        }

        const metadata = await response.json();

        // Check for error in response
        if (metadata.error) {
          throw new Error(`Service error: ${metadata.error.message || JSON.stringify(metadata.error)}`);
        }

        // Get layers from metadata
        const layers = metadata.layers || [];
        console.log('Available layers:', layers.map(l => ({ id: l.id, name: l.name })));

        if (layers.length === 0) {
          console.warn('No layers found in service metadata');
          return null;
        }

        // If a specific layer name is requested, find it
        if (options.layerName) {
          const targetName = options.layerName.toLowerCase();
          const matchedLayer = layers.find(layer =>
            layer.name && layer.name.toLowerCase().includes(targetName)
          );

          if (matchedLayer) {
            console.log(`Found matching layer: ${matchedLayer.name} (ID: ${matchedLayer.id})`);
            return {
              layerIndex: matchedLayer.id,
              layerInfo: matchedLayer,
              serviceMetadata: metadata
            };
          }
        }

        // Default to first layer if no specific name requested
        const firstLayer = layers[0];
        console.log(`Using first layer: ${firstLayer.name} (ID: ${firstLayer.id})`);
        return {
          layerIndex: firstLayer.id,
          layerInfo: firstLayer,
          serviceMetadata: metadata
        };

      } catch (error) {
        console.error('Error discovering feature service layer:', error);
        return null;
      }
    }

    /**
     * Query an ArcGIS Feature Service and return results as GeoJSON
     * @param {string} serviceUrl - The Feature Service URL (can be base URL or layer-specific)
     * @param {Object} options - Query options
     * @param {Array} options.bbox - Bounding box [minX, minY, maxX, maxY] in WGS84
     * @param {string} options.where - SQL where clause (default: "1=1")
     * @param {Array} options.outFields - Fields to return (default: ["*"])
     * @param {number} options.maxRecords - Max features to return (default: 1000)
     * @param {string} options.layerName - Optional layer name to discover (if serviceUrl is base URL)
     * @returns {Promise<Object>} - {success, data (GeoJSON FeatureCollection), error}
     */
    async function queryFeatureService(serviceUrl, options = {}) {
      try {
        let queryUrl = serviceUrl;

        // Check if the URL already has a layer index (ends with /N)
        const hasLayerIndex = /\/\d+\/?$/.test(serviceUrl);

        if (!hasLayerIndex) {
          // Need to discover the layer first
          console.log('No layer index found in URL, discovering layer...');
          const layerInfo = await discoverFeatureServiceLayer(serviceUrl, {
            layerName: options.layerName
          });

          if (!layerInfo) {
            throw new Error('Could not discover layer from service metadata');
          }

          // Construct the layer-specific URL
          queryUrl = `${serviceUrl.replace(/\/$/, '')}/${layerInfo.layerIndex}`;
          console.log('Discovered layer URL:', queryUrl);
        }

        // Build query parameters
        const params = new URLSearchParams({
          where: options.where || '1=1',
          outFields: options.outFields ? options.outFields.join(',') : '*',
          returnGeometry: 'true',
          outSR: '4326',  // Request WGS84 coordinates
          f: 'json'
        });

        // Add bounding box if provided
        if (options.bbox && options.bbox.length === 4) {
          const [minX, minY, maxX, maxY] = options.bbox;
          params.append('geometry', JSON.stringify({
            xmin: minX,
            ymin: minY,
            xmax: maxX,
            ymax: maxY
          }));
          params.append('geometryType', 'esriGeometryEnvelope');
          params.append('spatialRel', 'esriSpatialRelIntersects');
        }

        // Add max records limit
        if (options.maxRecords) {
          params.append('resultRecordCount', options.maxRecords);
        }

        // Execute query
        const fullQueryUrl = `${queryUrl}/query?${params.toString()}`;
        console.log('Querying Feature Service:', fullQueryUrl);

        const response = await fetch(fullQueryUrl);
        if (!response.ok) {
          throw new Error(`Query failed: ${response.status} ${response.statusText}`);
        }

        const arcgisJson = await response.json();

        // Check for error in response
        if (arcgisJson.error) {
          throw new Error(`Query error: ${arcgisJson.error.message || JSON.stringify(arcgisJson.error)}`);
        }

        // Convert ArcGIS JSON to GeoJSON
        const geojson = convertArcGIStoGeoJSON(arcgisJson);

        console.log(`Query successful: ${geojson.features.length} features returned`);

        return {
          success: true,
          data: geojson,
          error: null
        };

      } catch (error) {
        console.error('Feature Service query error:', error);
        return {
          success: false,
          data: null,
          error: error.message
        };
      }
    }

    /**
     * Convert ArcGIS JSON format to GeoJSON format
     * @param {Object} arcgisJson - ArcGIS REST API response
     * @returns {Object} - GeoJSON FeatureCollection
     */
    function convertArcGIStoGeoJSON(arcgisJson) {
      const features = (arcgisJson.features || []).map(arcgisFeature => {
        // Convert geometry
        const geometry = convertArcGISGeometry(
          arcgisFeature.geometry,
          arcgisJson.geometryType
        );

        return {
          type: 'Feature',
          properties: arcgisFeature.attributes || {},
          geometry: geometry
        };
      });

      return {
        type: 'FeatureCollection',
        features: features
      };
    }

    /**
     * Convert ArcGIS geometry to GeoJSON geometry
     * @param {Object} arcgisGeom - ArcGIS geometry object
     * @param {string} geometryType - ArcGIS geometry type
     * @returns {Object} - GeoJSON geometry
     */
    function convertArcGISGeometry(arcgisGeom, geometryType) {
      if (!arcgisGeom) return null;

      switch (geometryType) {
        case 'esriGeometryPoint':
          return {
            type: 'Point',
            coordinates: [arcgisGeom.x, arcgisGeom.y]
          };

        case 'esriGeometryPolyline':
          // ArcGIS polylines can have multiple paths
          if (arcgisGeom.paths && arcgisGeom.paths.length === 1) {
            return {
              type: 'LineString',
              coordinates: arcgisGeom.paths[0]
            };
          } else if (arcgisGeom.paths && arcgisGeom.paths.length > 1) {
            return {
              type: 'MultiLineString',
              coordinates: arcgisGeom.paths
            };
          }
          return null;

        case 'esriGeometryPolygon':
          // ArcGIS polygons can have multiple rings
          if (arcgisGeom.rings && arcgisGeom.rings.length === 1) {
            return {
              type: 'Polygon',
              coordinates: arcgisGeom.rings
            };
          } else if (arcgisGeom.rings && arcgisGeom.rings.length > 1) {
            return {
              type: 'MultiPolygon',
              coordinates: [arcgisGeom.rings]
            };
          }
          return null;

        default:
          console.warn('Unknown geometry type:', geometryType);
          return null;
      }
    }

    // ============================================
    // DATA LOADING
    // ============================================

    /**
     * Dynamically load all enabled GeoJSON datasets from the DATASETS configuration
     * Fetches all dataset files in parallel for better performance
     * @returns {Promise} Resolves when all data is loaded
     */
    async function loadGeoJsonData() {
      try {
        // Build array of fetch promises for all enabled datasets
        const fetchPromises = [];
        const datasetKeys = [];

        Object.keys(DATASETS).forEach(datasetKey => {
          const config = DATASETS[datasetKey];

          // Only load enabled datasets
          if (config.enabled) {
            fetchPromises.push(fetch(config.filePath));
            datasetKeys.push(datasetKey);
          }
        });

        // Fetch all datasets in parallel for better performance
        const responses = await Promise.all(fetchPromises);

        // Parse JSON data for each response
        const dataPromises = responses.map((response, index) => {
          const datasetKey = datasetKeys[index];
          const config = DATASETS[datasetKey];

          if (!response.ok) {
            console.warn(`Failed to load ${config.name}: ${response.status} ${response.statusText}`);
            return null;
          }

          return response.json();
        });

        const dataResults = await Promise.all(dataPromises);

        // Store loaded data and log results
        const loadedCounts = {};

        dataResults.forEach((data, index) => {
          const datasetKey = datasetKeys[index];

          if (data) {
            geoJsonData[datasetKey] = data;
            loadedCounts[datasetKey] = data.features ? data.features.length : 0;
          } else {
            geoJsonData[datasetKey] = null;
            loadedCounts[datasetKey] = 'failed';
          }
        });

        console.log('Data loaded successfully:', loadedCounts);

        // Validate coordinate systems for all loaded datasets
        Object.keys(DATASETS).forEach(datasetKey => {
          const config = DATASETS[datasetKey];
          if (config.enabled && geoJsonData[datasetKey]) {
            validateProjection(geoJsonData[datasetKey], config.name);
          }
        });

      } catch (error) {
        console.error('Error loading GeoJSON data:', error);
        throw error;
      }
    }

    /**
     * Validate that GeoJSON data is in WGS84 (EPSG:4326) coordinate system
     * Throws error if coordinates appear to be in projected CRS
     * @param {Object} data - GeoJSON FeatureCollection
     * @param {string} datasetName - Name of dataset for error messages
     */
    function validateProjection(data, datasetName) {
      if (!data.features || data.features.length === 0) {
        console.log(`⚠ ${datasetName}: No features to validate`);
        return true;
      }

      const firstFeature = data.features[0];
      let coords;

      // Extract first coordinate based on geometry type
      if (firstFeature.geometry.type === 'Point') {
        coords = firstFeature.geometry.coordinates;
      } else if (firstFeature.geometry.type === 'LineString') {
        coords = firstFeature.geometry.coordinates[0];
      } else if (firstFeature.geometry.type === 'Polygon') {
        coords = firstFeature.geometry.coordinates[0][0];
      } else if (firstFeature.geometry.type === 'MultiPolygon') {
        coords = firstFeature.geometry.coordinates[0][0][0];
      } else if (firstFeature.geometry.type === 'MultiLineString') {
        coords = firstFeature.geometry.coordinates[0][0];
      } else if (firstFeature.geometry.type === 'MultiPoint') {
        coords = firstFeature.geometry.coordinates[0];
      }

      if (!coords || coords.length < 2) {
        console.warn(`⚠ ${datasetName}: Could not extract coordinates for validation`);
        return true;
      }

      const [lng, lat] = coords;

      // Memphis area bounding box: lng -90.1 to -89.6, lat 34.9 to 35.3
      // Using slightly wider bounds (-91 to -89, 34 to 36) to allow for regional datasets
      const isValidWGS84 = (
        lng >= -91 && lng <= -89 &&
        lat >= 34 && lat <= 36
      );

      if (!isValidWGS84) {
        console.error(`❌ PROJECTION ERROR in ${datasetName}!`);
        console.error(`Found coordinates: [${lng}, ${lat}]`);
        console.error(`Expected Memphis area: lng -90 to -89, lat 34.9 to 35.3`);
        console.error(`Data appears to be in projected CRS, not WGS84!`);

        throw new Error(
          `${datasetName} has invalid coordinates. ` +
          `Found [${lng}, ${lat}]. ` +
          `Data must be in WGS84 (EPSG:4326), not projected coordinates. ` +
          `Please reproject the data to WGS84 before use.`
        );
      }

      console.log(`✓ ${datasetName} projection validated (WGS84): [${lng.toFixed(3)}, ${lat.toFixed(3)}]`);
      return true;
    }

    /**
     * Initialize the Leaflet map with basemap
     */
    function initializeMap() {
      // Create map instance
      map = L.map('map', {
        zoomControl: true,
        attributionControl: true
      });

      // Add CartoDB Voyager basemap (streets style, similar to Google Maps)
      const basemap = L.tileLayer(CONFIG.basemapUrl, {
        attribution: CONFIG.basemapAttribution,
        maxZoom: 19
      }).addTo(map);

      // Add scale control (bottom left)
      L.control.scale({
        imperial: true,
        metric: false,
        position: 'bottomleft'
      }).addTo(map);
    }

    /**
     * Dynamically add all reference layers to the map based on DATASETS configuration
     * Configures styling, tooltips, and hover interactions for each dataset
     */
    function addReferenceLayers() {
      const overlayLayers = {};

      // Loop through all enabled datasets and create layers
      Object.keys(DATASETS).forEach(datasetKey => {
        const config = DATASETS[datasetKey];

        // Skip if dataset is disabled or data not loaded
        if (!config.enabled || !geoJsonData[datasetKey]) {
          return;
        }

        try {
          let layer;

          // Create layer based on geometry type
          if (config.geometryType === 'Point') {
            // ========== POINT LAYERS ==========
            layer = L.geoJSON(geoJsonData[datasetKey], {
              pointToLayer: (feature, latlng) => {
                return L.circleMarker(latlng, config.style);
              },
              onEachFeature: (feature, leafletLayer) => {
                // Use staticLabel if defined, otherwise use field value
                const displayValue = config.properties.staticLabel ||
                                    feature.properties[config.properties.displayField] ||
                                    'Unknown';

                // Build tooltip text
                let tooltipText = displayValue;
                if (config.properties.additionalFields && config.properties.additionalFields.length > 0) {
                  config.properties.additionalFields.forEach(field => {
                    const value = feature.properties[field] || 'Unknown';
                    tooltipText += ` | ${field}: ${value}`;
                  });
                }

                // Bind tooltip
                leafletLayer.bindTooltip(tooltipText, {
                  sticky: true,
                  className: 'leaflet-tooltip'
                });

                // Hover effects
                const hoverStyle = { ...config.style, radius: (config.style.radius || 3) + 2 };
                leafletLayer.on('mouseover', function() {
                  this.setStyle(hoverStyle);
                });

                leafletLayer.on('mouseout', function() {
                  this.setStyle(config.style);
                });
              }
            });

          } else if (config.geometryType === 'LineString') {
            // ========== LINE LAYERS ==========
            layer = L.geoJSON(geoJsonData[datasetKey], {
              style: (feature) => {
                // Check if style should vary by property
                if (config.styleByProperty) {
                  const propertyValue = feature.properties[config.styleByProperty.field];
                  const propertyStyle = config.styleByProperty.values[propertyValue];
                  if (propertyStyle) {
                    return { ...config.style, ...propertyStyle };
                  }
                }
                return config.style;
              },
              onEachFeature: (feature, leafletLayer) => {
                // Use staticLabel if defined, otherwise use field value
                const displayValue = config.properties.staticLabel ||
                                    feature.properties[config.properties.displayField] ||
                                    'Unknown';

                // Bind tooltip
                leafletLayer.bindTooltip(displayValue, {
                  sticky: true,
                  className: 'leaflet-tooltip'
                });

                // Get current feature style for hover effects
                let currentStyle = config.style;
                if (config.styleByProperty) {
                  const propertyValue = feature.properties[config.styleByProperty.field];
                  const propertyStyle = config.styleByProperty.values[propertyValue];
                  if (propertyStyle) {
                    currentStyle = { ...config.style, ...propertyStyle };
                  }
                }

                // Hover effects
                const hoverStyle = { ...currentStyle, weight: (currentStyle.weight || 2) + 0.5, opacity: (currentStyle.opacity || 0.7) + 0.15 };
                leafletLayer.on('mouseover', function() {
                  this.setStyle(hoverStyle);
                });

                leafletLayer.on('mouseout', function() {
                  this.setStyle(currentStyle);
                });
              }
            });

          } else if (config.geometryType === 'Polygon') {
            // ========== POLYGON LAYERS ==========
            layer = L.geoJSON(geoJsonData[datasetKey], {
              style: config.style,
              onEachFeature: (feature, leafletLayer) => {
                // Use staticLabel if defined, otherwise use field value
                const displayValue = config.properties.staticLabel ||
                                    feature.properties[config.properties.displayField] ||
                                    'Unknown';

                // Bind tooltip
                leafletLayer.bindTooltip(displayValue, {
                  sticky: true,
                  className: 'leaflet-tooltip'
                });

                // Hover effects
                const hoverStyle = { ...config.style, fillOpacity: (config.style.fillOpacity || 0.3) + 0.2 };
                leafletLayer.on('mouseover', function() {
                  this.setStyle(hoverStyle);
                });

                leafletLayer.on('mouseout', function() {
                  this.setStyle(config.style);
                });
              }
            });
          }

          // Store layer
          if (layer) {
            featureLayers[datasetKey] = layer;

            // Create layer control label with colored symbol
            let symbol = '●';
            if (config.geometryType === 'Polygon') symbol = '■';
            if (config.geometryType === 'LineString') symbol = '─';

            const layerLabel = `<span style="color:${config.style.color};">${symbol}</span> ${config.name}`;
            overlayLayers[layerLabel] = layer;
          }

        } catch (error) {
          console.error(`Error creating layer for ${datasetKey}:`, error);
        }
      });

      // ========== LAYER CONTROL ==========
      // Add layer control to map if we have any layers
      if (Object.keys(overlayLayers).length > 0) {
        L.control.layers(null, overlayLayers, {
          collapsed: false,
          position: 'topright'
        }).addTo(map);
      }
    }

    /**
     * Calculate bounds from all data layers and fit map to show all features
     */
    function fitMapToBounds() {
      const bounds = L.latLngBounds([]);

      // Add bounds from all layers
      if (featureLayers.routes) bounds.extend(featureLayers.routes.getBounds());
      if (featureLayers.zones) bounds.extend(featureLayers.zones.getBounds());
      if (featureLayers.bridges) bounds.extend(featureLayers.bridges.getBounds());

      // Fit map to combined bounds with padding
      if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [50, 50] });
      }
    }

    // ============================================
    // DRAWING CONTROLS
    // ============================================

    /**
     * Set up Leaflet.draw controls for drawing project alignments
     * Only allows polyline drawing, one feature at a time
     */
    function setupDrawingControls() {
      // Create a feature group to store drawn items
      drawnItems = new L.FeatureGroup();
      map.addLayer(drawnItems);

      // Create draw handlers (but don't add toolbar to map)
      // These will be triggered programmatically from sidebar buttons
      polylineDrawer = new L.Draw.Polyline(map, {
        shapeOptions: CONFIG.drawnLineStyle,
        showLength: true,
        metric: false,  // Use imperial units (feet)
        feet: true
      });

      markerDrawer = new L.Draw.Marker(map, {
        icon: L.divIcon({
          className: 'project-marker',
          html: '<div style="background-color: #FF0000; width: 24px; height: 24px; border-radius: 50%; border: 3px solid white;"></div>',
          iconSize: [30, 30],
          iconAnchor: [15, 15]
        })
      });

      // Event handler: When drawing is created
      map.on(L.Draw.Event.CREATED, function(event) {
        onDrawCreated(event, drawnItems);
      });

      // Event handler: When drawing starts
      map.on(L.Draw.Event.DRAWSTART, function() {
        updateDrawButtonStates(true);
      });

      // Event handler: When drawing stops
      map.on(L.Draw.Event.DRAWSTOP, function() {
        updateDrawButtonStates(false);
      });
    }

    // ============================================
    // EVENT HANDLERS
    // ============================================

    /**
     * Handle completion of drawing a project alignment or location
     * Validates geometry and triggers spatial analysis
     * @param {Object} event - Leaflet draw event
     * @param {L.FeatureGroup} drawnItems - Feature group containing drawn items
     */
    function onDrawCreated(event, drawnItems) {
      const layer = event.layer;

      // Remove any previous drawing
      if (drawnLayer) {
        map.removeLayer(drawnLayer);
        drawnItems.clearLayers();
      }

      // Add new drawing to map
      drawnLayer = layer;
      drawnItems.addLayer(layer);

      // Convert to GeoJSON for analysis
      drawnGeometry = layer.toGeoJSON();

      // Validate geometry
      if (!validateGeometry(drawnGeometry)) {
        const geomType = drawnGeometry.geometry.type;
        if (geomType === 'LineString') {
          showError(`Project alignment must be at least ${CONFIG.minLineLength} feet long.`);
        } else {
          showError('Invalid geometry drawn. Please try again.');
        }
        map.removeLayer(drawnLayer);
        drawnLayer = null;
        drawnGeometry = null;
        return;
      }

      // Run spatial analysis on all datasets
      const results = analyzeAllDatasets(drawnGeometry);

      // Display results in sidebar
      displayResults(results);

      // Show project name/PDF section
      document.getElementById('projectNameSection').classList.add('visible');

      // Focus project name input
      document.getElementById('projectName').focus();
    }

    /**
     * Handle clear button click
     * Removes drawn feature and resets results
     */
    function onClearClicked() {
      // Remove drawn layer from map
      if (drawnLayer) {
        map.removeLayer(drawnLayer);
        drawnLayer = null;
        drawnGeometry = null;
      }

      // Clear results
      clearResults();

      // Hide project name/PDF section
      document.getElementById('projectNameSection').classList.remove('visible');
    }

    /**
     * Handle PDF button click
     * Generates and downloads PDF report
     */
    async function onPDFButtonClicked() {
      await generatePDF();
    }

    /**
     * Handle project name input
     * Enables/disables PDF button based on input
     */
    function onProjectNameInput() {
      const projectName = document.getElementById('projectName').value.trim();
      const pdfButton = document.getElementById('pdfButton');

      // Enable PDF button only if project name is entered and we have results
      pdfButton.disabled = !projectName || !drawnGeometry;
    }

    /**
     * Handle draw line button click
     * Triggers polyline drawing mode
     */
    function onDrawLineButtonClicked() {
      // Disable marker drawing if active
      if (markerDrawer._enabled) {
        markerDrawer.disable();
      }

      // Toggle polyline drawing
      if (polylineDrawer._enabled) {
        polylineDrawer.disable();
      } else {
        polylineDrawer.enable();
      }
    }

    /**
     * Handle draw point button click
     * Triggers marker drawing mode
     */
    function onDrawPointButtonClicked() {
      // Disable polyline drawing if active
      if (polylineDrawer._enabled) {
        polylineDrawer.disable();
      }

      // Toggle marker drawing
      if (markerDrawer._enabled) {
        markerDrawer.disable();
      } else {
        markerDrawer.enable();
      }
    }

    /**
     * Update visual state of draw buttons
     * @param {boolean} isDrawing - Whether drawing is active
     */
    function updateDrawButtonStates(isDrawing) {
      const lineButton = document.getElementById('drawLineButton');
      const pointButton = document.getElementById('drawPointButton');

      if (isDrawing) {
        if (polylineDrawer._enabled) {
          lineButton.classList.add('active');
          pointButton.classList.remove('active');
        } else if (markerDrawer._enabled) {
          pointButton.classList.add('active');
          lineButton.classList.remove('active');
        }
      } else {
        lineButton.classList.remove('active');
        pointButton.classList.remove('active');
      }
    }

    /**
     * Set up all event listeners for the application
     */
    function setupEventListeners() {
      document.getElementById('clearButton').addEventListener('click', onClearClicked);
      document.getElementById('pdfButton').addEventListener('click', onPDFButtonClicked);
      document.getElementById('projectName').addEventListener('input', onProjectNameInput);
      document.getElementById('drawLineButton').addEventListener('click', onDrawLineButtonClicked);
      document.getElementById('drawPointButton').addEventListener('click', onDrawPointButtonClicked);
      document.getElementById('zoomExtentButton').addEventListener('click', fitMapToBounds);
      document.getElementById('tutorialCloseButton').addEventListener('click', closeTutorial);
      document.getElementById('tutorialOverlay').addEventListener('click', closeTutorial);
    }

    // ============================================
    // SPATIAL ANALYSIS
    // ============================================

    /**
     * Clean corridor/route name by removing directional suffixes (IB, OB, EB, WB)
     * @param {string} name - Original corridor/route name
     * @returns {string} Cleaned corridor/route name
     */
    function cleanCorridorName(name) {
      if (!name) return 'Unknown';

      // Remove common directional suffixes (with optional space/dash before)
      // Handles: "Route 50 IB", "Route 50-OB", "Route 50IB", etc.
      return name
        .replace(/[\s\-]*(IB|OB|EB|WB)$/i, '')
        .trim();
    }

    /**
     * Analyze corridor match for LineString datasets
     * Works for any LineString dataset with corridor matching logic
     * @param {Object} drawnGeometry - GeoJSON geometry (LineString or Point)
     * @param {Object} datasetConfig - Configuration object from DATASETS
     * @param {Object} geoJsonData - GeoJSON FeatureCollection to analyze
     * @returns {Array} Array of matching feature names/IDs
     */
    function analyzeCorridorMatch(drawnGeometry, datasetConfig, geoJsonData) {
      const matchingFeatures = new Set();

      // Extract actual geometry from GeoJSON Feature if needed
      const geometry = drawnGeometry.type === 'Feature'
        ? drawnGeometry.geometry
        : drawnGeometry;

      // Create a buffer around the drawn geometry for tolerance
      const corridorBuffer = turf.buffer(geometry, datasetConfig.bufferDistance, {
        units: 'feet'
      });

      geoJsonData.features.forEach(feature => {
        try {
          let isMatch = false;

          if (geometry.type === 'LineString') {
            // Check if feature has significant overlap within the corridor
            if (turf.booleanIntersects(corridorBuffer, feature)) {
              try {
                const featureCoords = turf.getCoords(feature);
                let overlapLength = 0;

                // Check each segment of the feature
                for (let i = 0; i < featureCoords.length - 1; i++) {
                  const segment = turf.lineString([featureCoords[i], featureCoords[i + 1]]);

                  // Check if segment midpoint is within the corridor buffer
                  const midpoint = turf.midpoint(
                    turf.point(featureCoords[i]),
                    turf.point(featureCoords[i + 1])
                  );

                  if (turf.booleanPointInPolygon(midpoint, corridorBuffer)) {
                    overlapLength += turf.length(segment, { units: 'feet' });
                  }
                }

                // Feature matches if it has at least minSharedLength within the corridor
                isMatch = overlapLength >= datasetConfig.minSharedLength;

              } catch (clipError) {
                // Fallback: if processing fails, use simple intersection
                console.warn('Corridor analysis fallback:', clipError);
                isMatch = turf.booleanIntersects(corridorBuffer, feature);
              }
            }
          } else if (geometry.type === 'Point') {
            // Point: check if feature intersects buffer around point
            isMatch = turf.booleanIntersects(corridorBuffer, feature);
          }

          if (isMatch) {
            const featureName = feature.properties[datasetConfig.properties.displayField] || 'Unknown';

            // Apply special handling if configured
            let processedName = featureName;
            if (datasetConfig.specialHandling.removeDirectionalSuffixes) {
              processedName = cleanCorridorName(featureName);
            }

            matchingFeatures.add(processedName);
          }
        } catch (error) {
          console.warn('Error checking feature intersection:', error);
        }
      });

      // Convert Set to sorted array
      return Array.from(matchingFeatures).sort();
    }

    /**
     * Analyze intersection for Polygon datasets
     * Works for any Polygon dataset with intersection logic
     * @param {Object} drawnGeometry - GeoJSON geometry (LineString or Point)
     * @param {Object} datasetConfig - Configuration object from DATASETS
     * @param {Object} geoJsonData - GeoJSON FeatureCollection to analyze
     * @returns {Array} Array of intersecting feature names/IDs
     */
    function analyzeIntersection(drawnGeometry, datasetConfig, geoJsonData) {
      const intersectingFeatures = [];

      // Extract actual geometry from GeoJSON Feature if needed
      const geometry = drawnGeometry.type === 'Feature'
        ? drawnGeometry.geometry
        : drawnGeometry;

      geoJsonData.features.forEach(feature => {
        try {
          let intersects = false;

          if (geometry.type === 'LineString') {
            // Line-to-polygon intersection
            intersects = turf.booleanIntersects(geometry, feature);
          } else if (geometry.type === 'Point') {
            // Point-in-polygon check
            intersects = turf.booleanPointInPolygon(geometry, feature);
          }

          if (intersects) {
            const featureName = feature.properties[datasetConfig.properties.displayField] || 'Unknown';
            intersectingFeatures.push(featureName);
          }
        } catch (error) {
          console.warn('Error checking intersection:', error);
        }
      });

      // Sort by feature name
      return intersectingFeatures.sort();
    }

    /**
     * Analyze proximity for Point and Polygon datasets
     * Works for any Point or Polygon dataset with proximity buffer
     * @param {Object} drawnGeometry - GeoJSON geometry (LineString or Point)
     * @param {Object} datasetConfig - Configuration object from DATASETS
     * @param {Object} geoJsonData - GeoJSON FeatureCollection to analyze
     * @returns {Array} Array of nearby features with their properties
     */
    function analyzeProximity(drawnGeometry, datasetConfig, geoJsonData) {
      const nearbyFeatures = [];

      try {
        // Extract actual geometry from GeoJSON Feature if needed
        const geometry = drawnGeometry.type === 'Feature'
          ? drawnGeometry.geometry
          : drawnGeometry;

        // Create buffer around the drawn geometry
        const buffered = turf.buffer(geometry, datasetConfig.proximityBuffer, {
          units: 'feet'
        });

        // Check each feature against the buffer
        geoJsonData.features.forEach(feature => {
          try {
            let isNearby = false;

            if (datasetConfig.geometryType === 'Point') {
              // Point features: check if point is in buffer
              isNearby = turf.booleanPointInPolygon(feature, buffered);
            } else if (datasetConfig.geometryType === 'Polygon') {
              // Polygon features: check if polygon intersects buffer
              isNearby = turf.booleanIntersects(feature, buffered);
            }

            if (isNearby) {
              const featureData = {
                [datasetConfig.properties.displayField]:
                  feature.properties[datasetConfig.properties.displayField] || 'Unknown'
              };

              // Add additional fields if configured
              datasetConfig.properties.additionalFields.forEach(field => {
                featureData[field] = feature.properties[field] || 'Unknown';
              });

              nearbyFeatures.push(featureData);
            }
          } catch (error) {
            console.warn('Error checking proximity:', error);
          }
        });

        // Sort by display field
        nearbyFeatures.sort((a, b) => {
          const aVal = String(a[datasetConfig.properties.displayField]);
          const bVal = String(b[datasetConfig.properties.displayField]);
          return aVal.localeCompare(bVal);
        });

      } catch (error) {
        console.error('Error creating buffer or checking proximity:', error);
      }

      return nearbyFeatures;
    }

    /**
     * Master analysis function that loops through all enabled datasets
     * and calls the appropriate analysis function based on analysisMethod
     * @param {Object} drawnGeometry - GeoJSON of drawn line or point
     * @returns {Object} Analysis results keyed by dataset ID
     */
    function analyzeAllDatasets(drawnGeometry) {
      console.time('Spatial Analysis');

      const results = {};

      // Loop through all datasets in configuration
      Object.keys(DATASETS).forEach(datasetKey => {
        const config = DATASETS[datasetKey];

        // Skip if dataset is disabled or data not loaded
        if (!config.enabled || !geoJsonData[datasetKey]) {
          return;
        }

        try {
          let datasetResults = [];

          // Call appropriate analysis function based on method
          switch (config.analysisMethod) {
            case 'corridor':
              datasetResults = analyzeCorridorMatch(drawnGeometry, config, geoJsonData[datasetKey]);
              break;

            case 'intersection':
              datasetResults = analyzeIntersection(drawnGeometry, config, geoJsonData[datasetKey]);
              break;

            case 'proximity':
              datasetResults = analyzeProximity(drawnGeometry, config, geoJsonData[datasetKey]);
              break;

            default:
              console.warn(`Unknown analysis method: ${config.analysisMethod} for ${datasetKey}`);
          }

          // Store results keyed by dataset ID
          results[datasetKey] = datasetResults;

        } catch (error) {
          console.error(`Error analyzing ${datasetKey}:`, error);
          results[datasetKey] = [];
        }
      });

      console.timeEnd('Spatial Analysis');
      console.log('Analysis results:', results);

      // Store results globally
      currentResults = results;

      return results;
    }

    /**
     * Perform all spatial analyses on the drawn geometry (legacy wrapper)
     * This maintains backward compatibility while using the new system
     * @param {Object} drawnGeometry - GeoJSON of drawn line or point
     * @returns {Object} Analysis results containing routes, zones, and bridges
     * @deprecated Use analyzeAllDatasets() instead
     */
    function analyzeIntersections(drawnGeometry) {
      const allResults = analyzeAllDatasets(drawnGeometry);

      // Map new structure to old structure for backward compatibility
      return {
        routes: allResults.mataRoutes || [],
        zones: allResults.opportunityZones || [],
        bridges: allResults.bridges || []
      };
    }

    /**
     * Find all bridges within 300 feet of the drawn geometry
     * Creates a buffer around the line or point and checks point-in-polygon
     * @param {Object} featureOrGeometry - GeoJSON Feature or geometry (LineString or Point)
     * @returns {Array} Array of bridge objects {nbiId, condition}
     */
    function findNearbyBridges(featureOrGeometry) {
      const nearbyBridges = [];

      try {
        // Extract actual geometry from GeoJSON Feature if needed
        const geometry = featureOrGeometry.type === 'Feature'
          ? featureOrGeometry.geometry
          : featureOrGeometry;

        // Create 300-foot buffer around the drawn geometry (works for both lines and points)
        const buffered = turf.buffer(geometry, CONFIG.bridgeBufferDistance, {
          units: CONFIG.bridgeBufferUnits
        });

        // Check each bridge point against the buffer
        geoJsonData.bridges.features.forEach(bridge => {
          try {
            if (turf.booleanPointInPolygon(bridge, buffered)) {
              nearbyBridges.push({
                nbiId: bridge.properties.STRUCTURE_ || 'Unknown',
                condition: bridge.properties.Condition || 'Unknown'
              });
            }
          } catch (error) {
            console.warn('Error checking bridge proximity:', error);
          }
        });

        // Sort by NBI ID
        nearbyBridges.sort((a, b) => {
          return String(a.nbiId).localeCompare(String(b.nbiId));
        });

      } catch (error) {
        console.error('Error creating buffer or checking bridges:', error);
      }

      return nearbyBridges;
    }

    // ============================================
    // RESULTS DISPLAY
    // ============================================

    /**
     * Create HTML for a single results card
     * @param {Object} datasetConfig - Configuration from DATASETS
     * @param {Array} results - Analysis results for this dataset
     * @returns {string} HTML string for the results card
     */
    function createResultCard(datasetConfig, results) {
      const count = results.length;
      const hasResults = count > 0;

      let cardHtml = `<div class="results-card" data-dataset="${datasetConfig.id}">`;
      cardHtml += `<div class="section-heading">${datasetConfig.name} <span class="result-count">${count}</span></div>`;

      if (!hasResults) {
        cardHtml += `<p class="empty-state">No ${datasetConfig.name.toLowerCase()} found</p>`;
      } else if (datasetConfig.resultStyle === 'table') {
        // Table format (for datasets with additional fields like bridges)
        cardHtml += `<table style="width: 100%; border-collapse: collapse; margin-top: 10px; background-color: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">`;
        cardHtml += `<thead><tr>`;
        cardHtml += `<th style="background-color: #E6F2FF; padding: 10px; text-align: left; font-weight: bold; border: 1px solid #CCCCCC; font-size: 12px;">${datasetConfig.properties.displayField}</th>`;

        datasetConfig.properties.additionalFields.forEach(field => {
          cardHtml += `<th style="background-color: #E6F2FF; padding: 10px; text-align: left; font-weight: bold; border: 1px solid #CCCCCC; font-size: 12px;">${field}</th>`;
        });

        cardHtml += `</tr></thead><tbody>`;

        results.forEach((result, index) => {
          const bgColor = index % 2 === 0 ? 'white' : '#F9F9F9';
          cardHtml += `<tr style="background-color: ${bgColor};">`;
          cardHtml += `<td style="padding: 8px 10px; border: 1px solid #CCCCCC; font-size: 12px;">${result[datasetConfig.properties.displayField]}</td>`;

          datasetConfig.properties.additionalFields.forEach(field => {
            cardHtml += `<td style="padding: 8px 10px; border: 1px solid #CCCCCC; font-size: 12px;">${result[field]}</td>`;
          });

          cardHtml += `</tr>`;
        });

        cardHtml += `</tbody></table>`;
      } else {
        // List format (default)
        cardHtml += `<ul class="results-list">`;

        results.forEach(result => {
          let displayText;
          if (typeof result === 'string') {
            displayText = result;
          } else if (typeof result === 'object') {
            displayText = result[datasetConfig.properties.displayField] || 'Unknown';
          } else {
            displayText = String(result);
          }

          cardHtml += `<li>${displayText}</li>`;
        });

        cardHtml += `</ul>`;
      }

      cardHtml += `</div>`;

      return cardHtml;
    }

    /**
     * Display analysis results in the sidebar
     * Dynamically creates result cards for all datasets with results
     * @param {Object} results - Analysis results keyed by dataset ID
     */
    function displayResults(results) {
      // Get results container
      const resultsContainer = document.getElementById('resultsContainer');

      // Clear existing results
      resultsContainer.innerHTML = '';

      // Loop through DATASETS in order and create result cards
      Object.keys(DATASETS).forEach(datasetKey => {
        const config = DATASETS[datasetKey];

        // Skip disabled datasets or datasets without loaded data
        if (!config.enabled || !geoJsonData[datasetKey]) {
          return;
        }

        // Get results for this dataset
        const datasetResults = results[datasetKey] || [];

        // Create and append result card
        const cardHtml = createResultCard(config, datasetResults);
        resultsContainer.innerHTML += cardHtml;
      });

      // Enable PDF button if project name is entered
      onProjectNameInput();
    }

    /**
     * Clear all results from the sidebar
     * Resets to initial empty state
     */
    function clearResults() {
      // Get results container
      const resultsContainer = document.getElementById('resultsContainer');

      // Display placeholder message
      resultsContainer.innerHTML = `
        <div style="padding: 20px; text-align: center; color: #666;">
          <p style="font-size: 16px; margin: 0;">Draw a project to see analysis results</p>
          <p style="font-size: 13px; margin-top: 10px; color: #999;">Click "Draw Alignment" or "Mark Location" above to get started</p>
        </div>
      `;

      // Clear project name
      document.getElementById('projectName').value = '';

      // Disable PDF button
      document.getElementById('pdfButton').disabled = true;

      // Clear stored results
      currentResults = {};
    }

    // ============================================
    // PDF GENERATION
    // ============================================

    /**
     * Generate and download PDF report
     * Captures map view, formats results, and creates downloadable PDF
     */
    async function generatePDF() {
      const projectName = document.getElementById('projectName').value.trim();

      // Validate project name
      if (!projectName) {
        showError('Please enter a project name before generating the PDF.');
        return;
      }

      // Track which layers were visible before PDF generation
      const layerStates = {};
      Object.keys(DATASETS).forEach(datasetKey => {
        if (featureLayers[datasetKey]) {
          layerStates[datasetKey] = map.hasLayer(featureLayers[datasetKey]);
        }
      });

      try {
        // Disable button and show loading state
        const pdfButton = document.getElementById('pdfButton');
        const originalText = pdfButton.textContent;
        pdfButton.disabled = true;
        pdfButton.textContent = 'Generating PDF...';

        // Show loading overlay with PDF progress
        showLoading(true, 'Preparing map for PDF...');

        // Temporarily add all reference layers to map for PDF capture
        Object.keys(DATASETS).forEach(datasetKey => {
          if (featureLayers[datasetKey] && !layerStates[datasetKey]) {
            map.addLayer(featureLayers[datasetKey]);
          }
        });

        // Auto-zoom map to show drawn line and intersecting features
        // Use animate: false to ensure immediate positioning
        const optimalBounds = getOptimalMapBounds();
        if (optimalBounds) {
          map.fitBounds(optimalBounds, {
            padding: [80, 80],  // Increased padding for better centering
            maxZoom: 16,        // Prevent zooming in too close
            animate: false      // Critical: prevents capture during animation
          });
        }

        // === CRITICAL: Wait for all rendering to complete before capture ===

        // Step 1: Wait for basemap tiles to load at new position
        showLoading(true, 'Loading basemap tiles...');
        await waitForTilesToLoad();

        // Step 2: Wait for GeoJSON vector layers to render
        showLoading(true, 'Rendering vector layers...');
        await waitForGeoJSONLayersToRender();

        // Step 3: Give browser one more render cycle to finalize
        showLoading(true, 'Finalizing map display...');
        await new Promise(resolve => setTimeout(resolve, 500));

        // Step 4: Force Leaflet to recalculate internal state
        // This ensures all layer positions are correct
        map.invalidateSize();
        await new Promise(resolve => setTimeout(resolve, 200));

        // Now safe to capture
        showLoading(true, 'Capturing map image...');

        // Capture map as image using html2canvas
        const mapElement = document.getElementById('map');
        const canvas = await html2canvas(mapElement, {
          useCORS: true,
          allowTaint: true,
          scale: 2,  // Higher DPI for better quality
          logging: false,
          backgroundColor: '#ffffff',
          // Ensure we capture all layers
          onclone: function(clonedDoc) {
            // Force all Leaflet panes to be visible in clone
            const panes = clonedDoc.querySelectorAll('.leaflet-pane');
            panes.forEach(pane => {
              pane.style.opacity = '1';
              pane.style.visibility = 'visible';
            });
          }
        });

        // Restore layer visibility to previous state
        Object.keys(DATASETS).forEach(datasetKey => {
          if (featureLayers[datasetKey] && !layerStates[datasetKey]) {
            map.removeLayer(featureLayers[datasetKey]);
          }
        });

        showLoading(true, 'Building PDF document...');

        const mapImageData = canvas.toDataURL('image/png');

        // Create PDF using jsPDF
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
          orientation: 'portrait',
          unit: 'in',
          format: 'letter'  // 8.5 x 11 inches
        });

        // PDF dimensions (letter size with margins)
        const pageWidth = 8.5;
        const pageHeight = 11;
        const margin = 0.5;
        const contentWidth = pageWidth - (2 * margin);

        let yPosition = margin;

        // ========== HEADER SECTION ==========

        // Add logo (if available)
        try {
          // Note: For production, you may need to convert logo to base64
          // Project name as main title
          pdf.setFontSize(18);
          pdf.setFont('helvetica', 'bold');
          pdf.text(projectName, pageWidth / 2, yPosition, { align: 'center' });
          yPosition += 0.3;
        } catch (error) {
          console.warn('Could not add logo to PDF:', error);
        }

        // Project Application Report as subtitle
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'normal');
        pdf.text('Project Application Report', pageWidth / 2, yPosition, { align: 'center' });
        yPosition += 0.3;

        // Date generated
        pdf.setFontSize(10);
        pdf.setTextColor(128, 128, 128);
        const currentDate = new Date().toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        });
        pdf.text(`Generated: ${currentDate}`, pageWidth - margin, yPosition, { align: 'right' });
        yPosition += 0.2;

        // Project length (only for line features)
        if (drawnGeometry && drawnGeometry.geometry && drawnGeometry.geometry.type === 'LineString') {
          const lengthInMiles = turf.length(drawnGeometry.geometry, { units: 'miles' });
          pdf.text(`Project Length: ${lengthInMiles.toFixed(1)} miles`, pageWidth - margin, yPosition, { align: 'right' });
        }

        pdf.setTextColor(0, 0, 0);
        yPosition += 0.5;

        // ========== MAP SECTION ==========

        // Add map image
        const mapWidth = 7;
        const mapHeight = (canvas.height / canvas.width) * mapWidth;
        const mapX = (pageWidth - mapWidth) / 2;

        pdf.addImage(mapImageData, 'PNG', mapX, yPosition, mapWidth, mapHeight);
        yPosition += mapHeight + 0.4;

        // ========== RESULTS SECTION ==========
        // Only include sections that have results

        // Helper function to check if we need a new page
        const checkPageBreak = (neededSpace = 0.5) => {
          const footerSpace = 0.5;
          if (yPosition + neededSpace > pageHeight - footerSpace) {
            pdf.addPage();
            yPosition = margin;
            return true;
          }
          return false;
        };

        // Check if we have any results from any dataset
        const hasAnyResults = Object.keys(currentResults).some(datasetKey => {
          return currentResults[datasetKey] && currentResults[datasetKey].length > 0;
        });

        if (hasAnyResults) {
          checkPageBreak(0.5);
          pdf.setFontSize(12);
          pdf.setFont('helvetica', 'bold');
          pdf.text('Analysis Results', margin, yPosition);
          yPosition += 0.3;
        }

        // Loop through all datasets and add results dynamically
        Object.keys(DATASETS).forEach(datasetKey => {
          const config = DATASETS[datasetKey];

          // Skip if dataset is disabled or has no results
          if (!config.enabled || !currentResults[datasetKey] || currentResults[datasetKey].length === 0) {
            return;
          }

          const results = currentResults[datasetKey];

          // Add section header
          checkPageBreak(0.5);
          pdf.setFontSize(11);
          pdf.setFont('helvetica', 'bold');
          pdf.text(`${config.name}:`, margin, yPosition);
          yPosition += 0.2;
          pdf.setFontSize(10);
          pdf.setFont('helvetica', 'normal');

          // Render based on resultStyle
          if (config.resultStyle === 'table' && config.properties.additionalFields.length > 0) {
            // Table format
            pdf.setFont('helvetica', 'bold');

            // Table header
            const columnWidth = 2.5;
            let xOffset = margin + 0.2;

            pdf.text(config.properties.displayField, xOffset, yPosition);
            xOffset += columnWidth;

            config.properties.additionalFields.forEach(field => {
              pdf.text(field, xOffset, yPosition);
              xOffset += columnWidth;
            });

            yPosition += 0.18;
            pdf.setFont('helvetica', 'normal');

            // Table rows
            results.forEach(result => {
              checkPageBreak(0.2);
              xOffset = margin + 0.2;

              // Display field
              const displayValue = result[config.properties.displayField] || 'Unknown';
              pdf.text(String(displayValue), xOffset, yPosition);
              xOffset += columnWidth;

              // Additional fields
              config.properties.additionalFields.forEach(field => {
                const fieldValue = result[field] || 'Unknown';
                pdf.text(String(fieldValue), xOffset, yPosition);
                xOffset += columnWidth;
              });

              yPosition += 0.15;
            });

          } else {
            // List format (default)
            results.forEach(result => {
              checkPageBreak(0.2);

              let displayText;
              if (typeof result === 'string') {
                displayText = result;
              } else if (typeof result === 'object') {
                displayText = result[config.properties.displayField] || 'Unknown';
              } else {
                displayText = String(result);
              }

              pdf.text(`  • ${displayText}`, margin, yPosition);
              yPosition += 0.18;
            });
            yPosition += 0.15;
          }
        });

        // ========== FOOTER (on each page) ==========
        const totalPages = pdf.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
          pdf.setPage(i);
          pdf.setFontSize(8);
          pdf.setTextColor(128, 128, 128);
          const footerY = pageHeight - 0.3;
          pdf.text('Generated by Memphis MPO Project Application Tool', pageWidth / 2, footerY, { align: 'center' });
          if (totalPages > 1) {
            pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin, footerY, { align: 'right' });
          }
        }

        // ========== SAVE PDF ==========

        const fileName = formatFileName(projectName);
        pdf.save(fileName);

        // Hide loading overlay
        showLoading(false);

        // Re-enable button
        pdfButton.disabled = false;
        pdfButton.textContent = originalText;

      } catch (error) {
        console.error('PDF generation error:', error);

        // Restore layer visibility to previous state on error
        Object.keys(DATASETS).forEach(datasetKey => {
          if (featureLayers[datasetKey] && !layerStates[datasetKey] && map.hasLayer(featureLayers[datasetKey])) {
            map.removeLayer(featureLayers[datasetKey]);
          }
        });

        showLoading(false);
        showError('Failed to generate PDF. Please try again.');

        // Re-enable button
        const pdfButton = document.getElementById('pdfButton');
        pdfButton.disabled = false;
        pdfButton.textContent = 'Download PDF Report';
      }
    }

    /**
     * Calculate optimal map bounds to show drawn geometry
     * Focuses on the project area only, not entire intersecting features
     * Ensures the project is centered in the map view
     * @returns {L.LatLngBounds} Bounds object for map fitting
     */
    function getOptimalMapBounds() {
      if (!drawnLayer) return null;

      // Handle different layer types
      if (drawnLayer.getBounds) {
        // LineString - has getBounds method
        const lineBounds = drawnLayer.getBounds();
        const center = lineBounds.getCenter();
        const latDiff = Math.abs(lineBounds.getNorth() - lineBounds.getSouth());
        const lngDiff = Math.abs(lineBounds.getEast() - lineBounds.getWest());

        // Expand bounds evenly around center by 50% on each side for better framing
        const latPad = latDiff * 0.5;
        const lngPad = lngDiff * 0.5;

        // Create new bounds centered on the project center
        return L.latLngBounds([
          [center.lat - latDiff / 2 - latPad, center.lng - lngDiff / 2 - lngPad],
          [center.lat + latDiff / 2 + latPad, center.lng + lngDiff / 2 + lngPad]
        ]);
      } else if (drawnLayer.getLatLng) {
        // Point/Marker - use getLatLng
        const latlng = drawnLayer.getLatLng();
        // Create balanced bounds around the point (0.008 degrees ~ 800m for better framing)
        const offset = 0.008;
        return L.latLngBounds([
          [latlng.lat - offset, latlng.lng - offset],
          [latlng.lat + offset, latlng.lng + offset]
        ]);
      }

      return null;
    }

    /**
     * Format project name into valid filename for PDF download
     * Replaces spaces with underscores and adds ISO date
     * @param {string} projectName - User-entered project name
     * @returns {string} Formatted filename
     */
    function formatFileName(projectName) {
      // Replace spaces and special characters with underscores
      const sanitized = projectName.replace(/[^a-zA-Z0-9]/g, '_');

      // Get current date in YYYY-MM-DD format
      const date = new Date();
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;

      return `Project_Application_${sanitized}_${dateStr}.pdf`;
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    /**
     * Wait for all map tiles to finish loading
     * Returns a promise that resolves when tiles are loaded
     * @returns {Promise} Resolves when tiles are loaded or after timeout
     */
    function waitForTilesToLoad() {
      return new Promise((resolve) => {
        // Get the tile layer from map
        let tileLayer = null;
        map.eachLayer(layer => {
          if (layer instanceof L.TileLayer) {
            tileLayer = layer;
          }
        });

        if (!tileLayer) {
          console.warn('No tile layer found');
          resolve();
          return;
        }

        // Helper function to check pending tiles
        const checkTiles = () => {
          let pending = 0;
          const container = tileLayer.getContainer();
          if (container) {
            const tiles = container.querySelectorAll('img');
            tiles.forEach(tile => {
              if (!tile.complete) pending++;
            });
          }
          return pending;
        };

        // Check if tiles are already loaded
        const initialPending = checkTiles();
        console.log(`Basemap tiles: ${initialPending} pending`);

        if (initialPending === 0) {
          console.log('✓ All basemap tiles already loaded');
          resolve();
          return;
        }

        // Wait for 'load' event or timeout
        let resolved = false;
        let timeoutHandle;

        const onLoad = () => {
          const stillPending = checkTiles();
          if (!resolved && stillPending === 0) {
            resolved = true;
            clearTimeout(timeoutHandle);
            tileLayer.off('load', onLoad);
            tileLayer.off('tileerror', onTileError);
            console.log('✓ All basemap tiles loaded successfully');
            resolve();
          } else if (stillPending > 0) {
            console.log(`Basemap tiles: ${stillPending} still pending...`);
          }
        };

        const onTileError = (error) => {
          console.warn('Tile load error:', error);
          // Continue anyway - some tiles may have failed but we should proceed
        };

        tileLayer.on('load', onLoad);
        tileLayer.on('tileerror', onTileError);

        // Timeout fallback (5 seconds max wait - increased from 3s)
        timeoutHandle = setTimeout(() => {
          if (!resolved) {
            resolved = true;
            tileLayer.off('load', onLoad);
            tileLayer.off('tileerror', onTileError);
            const finalPending = checkTiles();
            console.warn(`⚠ Tile load timeout after 5s - ${finalPending} tiles still pending - proceeding anyway`);
            resolve();
          }
        }, 5000);
      });
    }

    /**
     * Wait for all GeoJSON vector layers to finish rendering in the DOM
     * GeoJSON layers render as SVG elements in the overlay pane
     * This ensures all vector features are visible before PDF capture
     * @returns {Promise} Resolves when layers are rendered or timeout (2s)
     */
    async function waitForGeoJSONLayersToRender() {
      return new Promise((resolve) => {
        let checks = 0;
        const maxChecks = 20; // 2 seconds max wait (20 * 100ms)

        const checkRendered = () => {
          checks++;

          // Find the Leaflet overlay pane that contains vector layers
          const overlayPane = document.querySelector('.leaflet-overlay-pane');
          if (!overlayPane) {
            if (checks < maxChecks) {
              setTimeout(checkRendered, 100);
            } else {
              console.warn('GeoJSON layers: overlay pane not found - proceeding anyway');
              resolve();
            }
            return;
          }

          // Count rendered SVG paths (GeoJSON features render as SVG)
          const svgPaths = overlayPane.querySelectorAll('svg path');
          const canvasElements = overlayPane.querySelectorAll('canvas');

          // Count total rendered elements
          const totalElements = svgPaths.length + canvasElements.length;

          // Log progress every 5 checks
          if (checks % 5 === 0 || checks === 1) {
            console.log(`GeoJSON render check ${checks}: ${svgPaths.length} SVG paths, ${canvasElements.length} canvas elements`);
          }

          // Consider rendered if we have some elements OR reached max checks
          // We expect at least a few paths for the drawn geometry + reference layers
          if (totalElements > 0 || checks >= maxChecks) {
            if (checks >= maxChecks && totalElements === 0) {
              console.warn('GeoJSON layers: timeout reached with no elements - check if layers are actually enabled');
            } else {
              console.log(`✓ GeoJSON layers rendered: ${totalElements} elements found after ${checks * 100}ms`);
            }
            resolve();
          } else {
            // Keep checking
            setTimeout(checkRendered, 100);
          }
        };

        checkRendered();
      });
    }

    /**
     * Validate drawn geometry meets minimum length requirement
     * For LineStrings: Uses Turf.js to calculate line length in feet
     * For Points: Always valid (no length requirement)
     * @param {Object} featureOrGeometry - GeoJSON Feature or geometry object
     * @returns {boolean} True if valid, false otherwise
     */
    function validateGeometry(featureOrGeometry) {
      try {
        // Extract actual geometry from GeoJSON Feature if needed
        const geometry = featureOrGeometry.type === 'Feature'
          ? featureOrGeometry.geometry
          : featureOrGeometry;

        console.log('Validating geometry type:', geometry.type);

        // Points are always valid
        if (geometry.type === 'Point') {
          console.log('Point geometry detected - validation passed');
          return true;
        }

        // For LineStrings, check minimum length
        if (geometry.type === 'LineString') {
          const length = turf.length(geometry, { units: 'feet' });
          console.log(`Drawn line length: ${length.toFixed(2)} feet`);
          return length >= CONFIG.minLineLength;
        }

        // Unknown geometry type
        console.warn('Unknown geometry type:', geometry.type);
        return false;
      } catch (error) {
        console.error('Geometry validation error:', error);
        return false;
      }
    }

    /**
     * Show user-friendly error message
     * @param {string} message - Error message to display
     */
    function showError(message) {
      alert(message);
    }

    /**
     * Show or hide loading overlay
     * @param {boolean} show - Whether to show or hide the overlay
     * @param {string} message - Optional loading message
     */
    function showLoading(show, message = 'Loading...') {
      const overlay = document.getElementById('loadingOverlay');
      const loadingText = document.getElementById('loadingText');

      if (show) {
        loadingText.textContent = message;
        overlay.style.display = 'flex';
      } else {
        overlay.style.display = 'none';
      }
    }

    // ============================================
    // FEATURE SERVICE TESTING (for development/debugging)
    // ============================================

    /**
     * Test function for Feature Service integration
     * This demonstrates how to properly query the ETRIMS roads service
     *
     * KEY FIX: This implementation properly discovers the layer index from service metadata
     * instead of blindly assumixng layer 0. The discoverFeatureServiceLayer() function
     * queries the FeatureServer base URL to get metadata about available layers, then
     * uses the correct layer index.
     *
     * Usage: Call testFeatureServiceQuery() from browser console to test
     */
    async function testFeatureServiceQuery() {
      console.log('=== Testing Feature Service Integration ===');

      // Test service URL (ETRIMS Roads)
      const serviceUrl = 'https://services2.arcgis.com/saWmpKJIUAjyyNVc/arcgis/rest/services/ETRIMS_Roads_All/FeatureServer';

      // Test bbox (downtown Memphis area as specified in spec)
      const testBbox = [-90.06, 35.13, -90.03, 35.16];

      console.log('1. Testing metadata discovery...');
      const layerInfo = await discoverFeatureServiceLayer(serviceUrl);
      if (layerInfo) {
        console.log('✓ Layer discovered:', {
          index: layerInfo.layerIndex,
          name: layerInfo.layerInfo.name,
          geometryType: layerInfo.layerInfo.geometryType
        });
      } else {
        console.error('✗ Failed to discover layer');
        return;
      }

      console.log('2. Testing feature query...');
      const result = await queryFeatureService(serviceUrl, {
        bbox: testBbox,
        maxRecords: 5
      });

      if (result.success) {
        console.log('✓ Query successful:', {
          featureCount: result.data.features.length,
          sampleFeature: result.data.features[0]
        });
      } else {
        console.error('✗ Query failed:', result.error);
      }

      console.log('=== Test Complete ===');
      return result;
    }

    // Make test function available in console for debugging
    window.testFeatureServiceQuery = testFeatureServiceQuery;
    window.queryFeatureService = queryFeatureService;
    window.discoverFeatureServiceLayer = discoverFeatureServiceLayer;

    // ============================================
    // START APPLICATION
    // ============================================

    // Initialize application when DOM is fully loaded
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
